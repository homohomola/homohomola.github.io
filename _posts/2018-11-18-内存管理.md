---
layout:     post
title:      OS内存管理
subtitle:   内存被管理方式
date:       2020-11-18
author:     sakura
header-img: img/the-first.png
catalog: true
tags:
    - 操作系统

---

## 3.1 内存管理概念

### 1. 内存的基本概念

内存是存放数据的硬件，程序执行前需要先放到内存中才能被CPU处理

问题：多道程序环境下，系统中有多个程序并发执行，多个程序的数据需要同时放到内存中，如何区分各个程序数据是放在什么地方的呢？

方案：

给内存存储单元编地址，按**字节编址**(一个存储单元为1字节)和**按字编址**(一个存储单元为机器字长)



#### 1.1 程序的装入和链接

进程的运行原理(指令)

实际在生成机器指令的时候并不知道进程的数据会被放到什么位置，所以编译生成的指令一般是使用**逻辑地址**(相对地址)

编译时产生的指令只关心**相对地址**，实际放入内存时再想办法根据起始位置得到**物理地址**(绝对地址)

![image-20201031131006385](https://gitee.com/happy_every/note_pic/raw/master/image-20201031131006385.png)

**编译**：由编译程序将源代码编译成若干个目标模块

**链接**：由链接程序将编译后形成的一组目标模块，以及需要库函数链接在一起，形成完整的装入模块

**装入**：由装入程序将装入模块装入内存运行

![image-20201031131052251](https://gitee.com/happy_every/note_pic/raw/master/image-20201031131052251.png)

##### 1. 装入的三种方式

###### 1.1 绝对装入

在编译时就知道程序将要放在内存的哪个位置，编译程序将产生绝对地址的目标代码

决对装入**只适用于单道程序环境**，此时还没OS由编译器实现

###### 1.2 静态重定位

又称**可重定位装入**，指令中使用的地址都是逻辑地址，装入时对内存进行**重定位**，地址变化是在装入时一次完成的(由装入重定位程序完成)

**特点**：在一个作业装入内存时，**必须分配其要求的全部内存空间**，如没有足够的内存空间，就不能装入作业；作业一旦进入内存后，**在运行期间就不能移动**，也不能重新申请内存空间

适用于早期多道批处理操作系统

###### 1.2 动态重定位

又称**动态运行时装入**，程序指令内都是逻辑地址，**把地址转换放到程序真正要执行时刻**，需要**重定位寄存器**的支持

重定位寄存器中存放装入模块存放的起始位置

采用动态重定位时，允许程序在内存中发生移动，并且可将程序分配到不连续的存储区中，在程序运行前只需装入部分代码即可运行，在程序运行期间根据需求动态申请分配内存，可以向用户提供比存储空间大得多的地址空间



|                | 区别                                           |
| -------------- | ---------------------------------------------- |
| 静态装入       | 编程阶段就把物理地址计算好                     |
| 可重定位装入   | 装入时就把逻辑地址换出物理地址，装入后不能改变 |
| 动态重定位装入 | 执行时再决定装入的地址                         |



##### 2. 链接的三种方式

###### 2.1 静态链接

在程序运行前，将各目标模块及所需的库函数连接成一个完整的可执行文件(装入模块)

###### 2.2 装入时动态链接

将各目标文件模块装入内存时，边装入内存边链接的链接方式

###### 2.3 运行时动态链接

在程序执行中需要该目标模块时，才对它进行链接

**优点**:便于修改和更新，便于实现对目标模块的共享



#### 1.2 内存保护

内存分配前需要保护OS不受用户进程的影响，同时保护用户进程不受其他用户进程的影响

内存保护的两种方式

- 在CPU中设置一对上、下限寄存器，存放用户作业在主存中的上下限地址，进程的指令每次要访问地址时，由CPU检测是否越界
- 采用**重定位寄存器**(基址寄存器)和**界地址寄存器**(限长寄存器)进行越界检测，界地址寄存器存放**最大逻辑地址**



### 2. 覆盖与交换

#### 2.1 覆盖技术

覆盖技术的思想：将**程序分为多个段**(多个模块)，常用的段常驻内存，不常用的段在需要时调入内存，要不到时调出内存

内存中分为一个**固定区**和若干个**覆盖区**

![image-20201031140542646](https://gitee.com/happy_every/note_pic/raw/master/image-20201031140542646.png)

**缺点**：必须由程序员声明覆盖结构，OS完成自动覆盖，对用户不透明，增加了用户编程负担(只用于早期OS)

#### 2.2 交换技术

又称对换技术的思想：内存空间紧张时，系统将内存中某些进程暂时**换出**外存，把外存中已具备运行条件的进程**换入**内存

中级调度(内存调度)：决定将哪个挂起状态的进程重新调入内存

**挂起态**：暂时换出外存等待的进程状态，可细分为**就绪挂起**和**阻塞挂起**

![image-20201031141111329](https://gitee.com/happy_every/note_pic/raw/master/image-20201031141111329.png)

**问题**

> 1. 应该在外存的什么位置保存被换出的进程
>
> 2. 什么时候应该交换
>
> 3. 应该换出哪些进程

1. 具有对换功能的OS中，通常把磁盘空间分为**文件区**和**对换区**。文件区用于存放文件，追求存储空间的利用率，对文件空间的管理采取离散分配方式；对换取只占磁盘空间的小部分，被换出的进程数据就存放在对换取，最求换入换出速度，对换取采用连续分配方式
2. 交换通常在许多进程运行且内存吃紧时进程，而系统负荷降低就停止
3. 可优先换出阻塞进程、优先级低的进程(**PCB会常驻内存**)

#### 2.3 覆盖与交换的区别

覆盖是在同一进程或程序中的

交换时在不同进程或作业间的



### 3. 连续分配管理方式

**连续分配**：用户进程分配的必须是一个连续的内存空间

#### 3.1 单一连续分配

内存被分为**系统区**和**用户区**，系统区位于内存的低地址部分，用于存放OS相关数据；用户区用于存放用户进程相关数据

内存中**只能有一道用户程序**，用户程序独占整个用户区空间

![image-20201031194614942](https://gitee.com/happy_every/note_pic/raw/master/image-20201031194614942.png)

**优点**：实现简单；**无外部碎片**，可以采用覆盖技术扩充内存；不一定需要采用内存保护

**缺点**：只能用于单用户、单任务的OS中；**有内部碎片**；存储器利用率低

**内部碎片**：分配给某进程的内存区域中，没有用上的部分



#### 3.2 固定分区分配

将整个用户空间划分为**固定大小分区**，在**每个分区只装入一道程序**，形成最早、早简单的一种可运行多道程序的内存管理方式

**分区大小相对**：缺乏灵活性，但是很适合用于一台计算机控制多个相同对象的场合

**分区大小不等**：增加了灵活性，可以满足不同大小的进程需求，根据常在系统中运行的作业大小情况划分



OS需要建立一个数据结构(**分区说明表**)，来实现各个分区的分配与回收。每个表项包括对应分区的**大小、起始地址、状态(是否已分配)**

当某用户程序要装入内存时，由OS内核程序根据用户进程大小检索该表，找到合适的分区，将之分配，修改状态为已分配



**优点**：实现简单，**无外部碎片**

**缺点**：当用户程序太大时，可能所有的分区都不能满足需求，此时不得不采取覆盖技术，降低性能；**会产生内部碎片**，内存利用率地



#### 3.3 动态分区分配

又称**可变分区分配**，不预先划分内存分区，在进程装入内存时，**根据进程大小动态地建立分区**，使分区大小正好适合进程的需要



##### 1. 记录内存的数据结构

**空闲分区表**

![image-20201031200852689](https://gitee.com/happy_every/note_pic/raw/master/image-20201031200852689.png)

每一个表项对应一个空闲分区

**空闲分区链**

![image-20201031200901413](https://gitee.com/happy_every/note_pic/raw/master/image-20201031200901413.png)

每各分区的起始部分记录分区大小等信息



##### 2. 分区的分配和回收

**相邻的空闲区间要合并**



动态分区分配没有内部碎片，但有外部碎片

**内部碎片**：分配给进程的内存区域中，没有用上的部分

**外部碎片**：内存的中的某些空闲空间太小太零散难以利用

可以通过**紧凑**极速来解决外部碎片，将进程移位，修改进程起始位置，并重定位(开销大)



#### 3.4 动态分区分配算法

##### 1. 首次适应算法(First Fit)

**算法思想**：每次从低地址开始查找， 找到第一个能满足大小的空闲分区

**实现原理**：空闲分区以地址递增的次序排列，每次分配内存时顺序查找空闲分区表/链

**优点**：综合性能最好，开销小，不需要重新排序空闲队列



##### 2. 最佳适应算法(Best Fit)

**算法思想**：为了保证大进程到来时能有连续的大片空间，优先使用更小的空闲去

**实现原理**：空闲区间按**容量递增次序链接**，每次分配内存顺序查找

**缺点**：每次都选最小的分区进行分配，会留下越来越多的、很小的、难以利用的内存块，会产生**很多的外部碎片**；需要更新空闲分区，算法开销大



##### 3. 最坏适应算法(Worst Fit)

**算法思想**：在每次分配时优先使用最大的连续空闲去分配后剩余的空闲区就不会太小，更方便使用

**实现原理**：空闲分区按**容量递减次序链接**，每次分配内存时顺序查找

**缺点**：会导致较大的连续空闲区被迅速用完，之后有大进程到来，就无法分配内存；需要更新空闲分区，算法开销大



##### 4. 邻近适应算法(Next Fit)

**算法思想**：首次适应算法每次都从链头开始查早，可能会导致低地址部分出现很多的小空闲分区，每次分配查找时都要经过这些分区，增加查找的开销，所以每次**从上次查找结束的位置开始检索**

**实现原理**：空闲分区以地址递增顺序排列(可排成循环链表)，每次从上次查找结束位置开始查找

**缺点**：也会导致高地址的大分区被用完



### 4. 非连续性分配

允许将一个进程分散装入到许多不相邻的分区，便可充分利用内存，为用户分配的是一些分散的内存空间

#### 4.1 基本分页存储管理

##### 1. 基本概念

**基本分页存储管理的思想**：把内存分为一个个大小相等的小分区，再按照分区大小把进程拆分成一个个小部分

**基本概念**：

每个分区就是一个**页框**(页帧、内存块、物理块)，每个页框有一个编号，即**页框号**，从0开始

将用户进程的地址空间分为与**页框大小相等**的区域(**页面**)，页面的编号称为**页号**，从0开始

页框不能太大，否则可能产生过大的内部碎片

OS以页框为单位给进程分配内存空间，进程的页面与内存的页框**一一对应**，页面不必连续存放，也不必按顺序存放



**地址转换的实现**

1. 计算逻地址对应的页号
2. 知道该页号对应**内存中的起始地址**
3. 算出逻辑地址在**该页面内的偏移量**
4. 物理地址=页面起始地址+页内偏移量

页号=逻辑地址/页面超度

页内偏移量=逻辑地址%页面长度

如果每个页面大小为$2^kB$,用二进制表示逻辑地址，则**末尾K位**即为页内偏移量，其余部分是页号



**页表**

OS为每个进程建立一张页表

- 一个进程对应一张页表
- 进程的每一页对应一个页表项
- 每个**页表项**由页号和块号组成
- 页表记录进程页面和实际存放内存块间的对应关系

页号是隐含的(页表项按顺序连续存放在内存中)**ps：感觉相当于数组的下标**，实际只储存块号



##### 2.  基本地址变化机构

在系统中设置一个**页表寄存器**(PTR)，存放页表在内存中的**起始地址F**和**页表长度**，页表的起始地址和长度放入**进程控制块**(PCB)，

![image-20201101093809588](https://gitee.com/happy_every/note_pic/raw/master/image-20201101093809588.png)

1. 根据逻辑地址计算页号、页内偏移量
2. 判断页号是否越界(页号从0开始，页表长度至少为1,P<M)
3. 查询页表，遭到对应内存块号
4. 计算得到物理地址
5. 访问内存单元

**总共访问两次内存单元**



**页表项长度、页表长度、页面大小的区别**

页表项长度：每个页表占的**存储空间**

页表长度：页表页表项的**数量**

页面大小：一个页面占的**存储空间**

为了方便页表的查询，通常会让页表项占更多的字节，使每个页面恰好可以装的下整数个页表项，页表一般放在连续的内存块中



##### 3. 具有块表的地址变化机构

###### 1. 局部性原理

**时间局部性**：如果执行或访问某条指令或数据，不久后可能再次执行、访问

**空间局部性**：一旦程序访问了某个存储空间，不久后，附近的存储单元很有可能被访问

###### 2. 快表

又称**联想寄存器(TLB)**，一种高速缓冲存储器，内存中的页表常称为**慢表**

![image-20201101101107262](https://gitee.com/happy_every/note_pic/raw/master/image-20201101101107262.png)

1. 算页号、页内偏移量
2. 检查页号合法性
3. 查**快表**，若命中可直接得到内存块号
4. 未命中，则查页表，并**复制页表项到快表中**



4. 两级页表

单级页表的问题

- 页表必须连续存放，当页表很大时，需要占用很多个连续的空间(采用多级页表)
- 根据局部性原理，进程一段时间内只需要访问几个特定的页面，没必要让进程的整个页表常驻内存(**采用虚拟存储技术**)



将页表分组，将每个内存块刚好可以放入分组，为离散分配的分组再建立一张页表，称为**页目录表**，或外层页表、顶层页表

![image-20201101103134515](https://gitee.com/happy_every/note_pic/raw/master/image-20201101103134515.png)

采用多级页表机制，**各级页表的大小不能超过一个页面**，访存次数等于N+1次，N为级数



#### 4.2 基本分段储存管理

引入段式存储管理方式主要是为了满足用户的要求：方便编程、分段共享、分段保护、动态链接、动态增长

##### 1.  分段

进程地址空间按程序**自身的逻辑**关系划分为若干个段，每个段都有一个段名(在低级语言中，程序员使用段名来编程),每段从0开始

内存分配规则：以段为单位进行分配，每个段占据连续的内存空间，但段间可以不相邻

![image-20201101104949880](https://gitee.com/happy_every/note_pic/raw/master/image-20201101104949880.png)

编译程序会将段名转化为段号

![image-20201101105235537](https://gitee.com/happy_every/note_pic/raw/master/image-20201101105235537.png)

段号的位数决定进程最多等段数，段内地址数决定每个段的最大长度

##### 2. 段表

![image-20201101105506194](https://gitee.com/happy_every/note_pic/raw/master/image-20201101105506194.png)

1. 每个段对应一个段表项，记录起始位置和段的长度
2. 各个段表项长度是相同的，段号是隐含的，不占存储空间

![image-20201101110415885](https://gitee.com/happy_every/note_pic/raw/master/image-20201101110415885.png)

1. 由逻辑地址得到段号、段内地址
2. 段号与段表长度M比较，检测是否越界
3. 由段表起始地址F、段号找到对应段表项
4. 检查段内地址是否越界
5. 基址b+段内地址W等于最终物理地址



#### 4.3 分页和分段的对比

页是信息的物理单位，分页的目的是为了实现离散分配，提高内存利用率，分页仅仅是系统管理的需要，是系统行为，对用户是不可见的

段是信息的逻辑单位，分段的目的是更好的满足用户需求，一个段通常包含一组属于一个逻辑模块的信息，分段对用户是可见的，用户编程时需要显式给出段名

分页的用户进程**地址空间是一维的**，程序员只需给出一个记忆符几个表示一个地址

分段的用户进程**地址空间是二维的**，程序员在标识地址时，既要给出段名，也要给出段内地址



**分段比分页更容易实现信息的共享和保护**，分页不是按逻辑模块划分，难以实现共享

![image-20201101111342646](https://gitee.com/happy_every/note_pic/raw/master/image-20201101111342646.png)

![image-20201101111533182](https://gitee.com/happy_every/note_pic/raw/master/image-20201101111533182.png)



不能被修改的代码称为**纯代码**或**可重入代码**(不属于临界资源)，是可共享的代码。可修改的代码是不能共享的

分段存储中也可引入快表机制，加速访问



#### 4.4 段页式管理

|          | 优点                                               | 缺点                                               |
| -------- | -------------------------------------------------- | -------------------------------------------------- |
| 分页管理 | 内存利用率高，不会产生外部碎片，只有少部分页内碎片 | 不方便实现按照逻辑模块实现信息的共享和保护         |
| 分段管理 | 很方便的按照逻辑模块实现信息的共享和保护           | 段过大会导致为其分配连续空间不方便，会产生外部碎片 |

![image-20201101142349048](https://gitee.com/happy_every/note_pic/raw/master/image-20201101142349048.png)

段页式系统的逻辑结构由段号、页号、页内偏移量组成

![image-20201101142509441](https://gitee.com/happy_every/note_pic/raw/master/image-20201101142509441.png)

段号位数决定每个进程最多分段数

页号位数决定每个段的的页数

页内偏移量决定页面大小、内存块大小



锻页式管理中段表记录**页表长度**和**页表存放地址**

![image-20201101143145466](https://gitee.com/happy_every/note_pic/raw/master/image-20201101143145466.png)

1. 由逻辑地址得到段号、页号、页内偏移量
2. 段号与段表寄存器中的段长度比较，检查是否越界
3. 由段表起始地址、和段号找到段表项
4. **根据段表项中记录的页表长度，检查页号是否越界**
5. 由相应页表里存放的内存块号、页内偏移量得到最终的物理地址



## 3.2 虚拟内存管理

### 1. 基本概念

#### 1.1 传统存储管理的特征和缺点

传统存储管理方式的特征

**一次性**：作业必须一次性全部装入内存后才能开始运行，会导致两个问题：作业很大时，不能全部装入内存，导致**大作业无法运行**；当大量作业运行时，内存无法容纳所有作业，只有少量作业能运行，导致**多道程序并发度下降**

**驻留性**：一旦作业装入内存，就会**一直驻留在内存**中，直到作业运行结束，导致内存中驻留了大量暂时用不到的数据，浪费了内存空间

#### 1.2 局部性原理

**时间局部性**：如果执行或访问某条指令或数据，不久后可能再次执行、访问

**空间局部性**：一旦程序访问了某个存储空间，不久后，附近的存储单元很有可能被访问

局部原理适用于程序结构，又适用于数据结构

**高速缓冲技术**的思想：将近期会频繁访问到的数据放到更高速的存储器

#### 1.3 虚拟存储器的定义和特征

程序装入时，可以将程序中很快会用到的模块装入内存

执行过程中，当访问信息不在内存中时，由OS负责调入所需信息

若内存空间不够，由OS负责将内存中暂时用不到的信息换出外存

**虚拟存储器**：OS为用户提供一个比实际内存大得多的存储器



虚拟内存的**最大容量**是计算机的地址结构(CPU的寻址范围)确定的

虚拟内存的**实际容量**=min(内存+外存，CPU寻址范围)



**特征**：

**多次性**：无需在作业运行时一次性装入内存

**对换性**：允许在作业运行时，将作业换入换出

**虚拟性**：从逻辑上扩充内存，使用户看到的容量大于实际的



#### 1.4 虚拟内存技术的实现

虚拟内存技术的实现需要建立在**离散内存**的内存管理方式上

**虚拟内存的实现方式**

- 请求分页存储管理
- 请求分段存储管理
- 请求段页式存储管理

**OS需要实现的功能**

- **请求调页**(调段)：将所需信息从外存调入内存
- **页面置换**(段置换)：将用不到的信息换出外存



### 2. 请求分页管理

#### 2.1 页表机制

请求分页管理的页表

![image-20201101184127716](https://gitee.com/happy_every/note_pic/raw/master/image-20201101184127716.png)

- 状态位：表示页面是否在内存中
- 访问字段：记录最近被访问几次，或上次访问时间，用于置换算法
- 修改位：表示页面调入内存后是否被修改过
- 外存地址：页面在外存中的地址



#### 2.2 缺页中断机构

每当访问的页面不在内存中时，便产生一个**缺页中断**，然后由OS的**缺页中断处理程序**处理中断

此时**缺页的进程阻塞**，放入阻塞队列，调页完成后将其唤醒，放回就绪队列

如果内存中由空闲块，则为进程分配一个空闲块，将所缺页面装入，并修改页表中对应的页表项

如果内存中没有空闲块，则由**页面置换算法**选择一个页面淘汰，如果该页面被修改过，则要将其**写回外存**，未修改过的不用写回



缺页中断属于**内中断**中的**故障**(可能被故障处理程序修复，如缺页中断)

一条指令执行期间，可能产生多次中断



#### 2.3 地址变化机构



![image-20201101185128731](https://gitee.com/happy_every/note_pic/raw/master/image-20201101185128731.png)

- 只有写指令才需要更改**修改位**，一般只需要修改**快表**中的数据，只有要将快表项删除时，才需写回内存的慢表
- 缺页中断需要保留CPU现场，换入换出需要慢速的I/O操作，换入换出太频繁会增加开销
- 页面调入内存后，需要修改慢表，同时复制到快表
- 若某个页面被换出外存，外表中的相应表项也要删除，否则可能访问错误的页面

### 3. 页面置换算法

页面置换算法应该**最求更少的缺页率**，因为磁盘I/O开销大

#### 3.1 最佳置换(OPT)

**算法思想**：每次选择**淘汰的页面**是**最长时间内不再被使用**或永不使用，保证最低的缺页率

实际上，只有进程执行过程中才能知道接下来会访问到哪个页面，OS无法提前预判页面访问序号，最佳置换算法**是无法实现的**。



#### 3.2 先进先出置换(FIFO)

**算法思想**：每次选择淘汰的页面是**最早进入内存的页面**

**实现方式**：把调入内存的页面根据调入顺序排成队列，需要换出页面时选择队头页面

**Belady异常**：当为进程分配的物理块增大时，缺页次数不增反减的异常现象

**只有FIFO算法会产生Belady异常**，该算法与进程实际运行时的规律不适应，先进入的页面可有可能被经常访问，**算法性能差**



#### 3.3 最近最久未使用置换(LRU)

**算法思想**：每次淘汰的页面是**最近最久未使用的页面**(least recently used)

**实现方式**：在页表项中，用访问字段记录该页面之上次访问以来经历的时间，选择时间最大的淘汰

需要专门的硬件支持，虽然算法性能好，但是**实现困难，开销大**



#### 3.4 时钟置换(CLOCK)

又称**最近未用算法**(NRU,Not Recently Used)

**实现方式**

- 为每个页面设置访问位，再将内存中的页面通过指针**链接成循环队列**
- 当页面被访问时，访问位置1
- 当淘汰页面时，检查页的访问位，如果是0，就换出；是1，就置为0，并继续检查下一个页面

简单CLOCK算法最多经过两轮扫描淘汰一个页面



#### 3.5 改进型的时钟置换

**算法思想**：在其他条件相同时，应该先淘汰没有被修改过的页面，避免I/O操作

**实现方式**

- 用（访问位，修改位）的形式表示页面状态，将所有页面排除循环队列
- 第一轮：扫描到第一个(0,0)替换
- 第二轮：扫描到第一个(0,1)替换，修改访问位为0
- 第三轮：扫描到第一个(0,0)替换

- 第四轮：扫描到第一个(0,1)替换

算法开销小，性能不错



### 4. 页面分配策略

#### 4.1 分配、置换策略

**驻留集**：请求分页存储管理中给进程分配的物理块的集合

若驻留集太小，会导致缺页频繁，系统要花大量时间处理缺页

驻留集太大，会导致多道程序**并发度下降**，资源利用率低



**固定分配**：OS为每个进程分配一组固定数目的物理块，**驻留集大小不变**

**可变分配**：先分配一定数量的物理块，根据情况适当增加或减少，**驻留集大小可变**



**局部置换**：发生缺页时只能选**自身的物理块**进行置换

**全局置换**：可以将OS保留的空闲物理块分配给缺页进程，可以将其他进程的物理块置换到外存，再分配给进程

![image-20201101202618509](https://gitee.com/happy_every/note_pic/raw/master/image-20201101202618509.png)

**固定分配局部置换**

缺点：很难再开始就确定为每个进程分配多少物理块才算合理



**可变分配全局置换**

发生缺页时，若无空闲物理块，则选择一个**未锁定**的页面换出外存,再将该物理块分配给缺页的进程

缺点：被选择进程拥有的物理块会减少，缺页率增加



**可变分配局部置换**

缺页时，只允许从自身物理块选择并换出外存；如果频繁缺页，系统会为进程多分配几个物理块；缺页率低，则适当减少进程的物理块；直到缺页率合适



#### 4.2 调入页面时机

**预调页策略**：根据局部性原则，一次调入若干相邻页面比一次调入一个页面更高效，当如果提前调入的页面都没有访问到，则又是低效的，所以主要用于**进程的首次调入**，由程序员指出项调入的部分

**请求调页策略**：进程在运行时发现缺页才将所缺页面调入内存，I/O开销较大



#### 4.4 从何处调页

如果系统拥**有足够的对换空间**：页面的调入调出都是在内存和对换区间进行，在进程运行前需要将进程相关的数据从文件区复制到对换区

**缺少足够的对换空间**：凡是不会被修改的数据都从文件区调入，对于需要修改的部分，换出时写回对换取，需要时从对换区调入

**UNIX方式**：未使用过的页面，都从文件区调入，若被使用过的页面需要换出，写回到对换区，需要时从对换区调入

#### 4.5 抖动(颠簸)现象

**抖动**：刚换出的页面马上又换入内存，刚换入的页面马上又换出外存

**主要原因**：分配给进程的物理块不够

#### 4.6 工作集

**工作集**：在某段时间间隔内，进程实际访问页面的集合

OS会根据**窗口尺寸**来算出工作集

![image-20201101205638262](https://gitee.com/happy_every/note_pic/raw/master/image-20201101205638262.png)

一般来说，**驻留集大小不能小于工作集**，否则会发生频发的缺页

#### 4.7 地址翻译

TODO