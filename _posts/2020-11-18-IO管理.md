---
layout:     post
title:      OS概念
subtitle:   I/O管理方式
date:       2020-11-18
author:     sakura
header-img: img/the-first.png
catalog: true
tags:
    - 操作系统

---

## 5.1 I/O管理概述

### 1. I/O设备

unix系统将外部设备抽象为一种特殊的文件，用户可是使用与文件相同的方式对外部设备进行操作

I/O设备的分类

- 按使用特性分类
    - 人机交互
    - 存储设备
    - 网络通信

- 按传输速率分类
    - 低速
    - 中速
    - 高速

- **按信息交换的单位分类**
    - 块设备(传输快、可寻址)
    - 字符设备(传输慢、不可寻址、常采用**中断驱动**方式)

### 2. I/O控制管理

#### 2.1 I/O控制器

I/O设备由**机械部件**和**电子部件**组成

CPU无法直接控制机械部件，I/O设备还需有一个**电子部件**作为CPU和I/O设备机械部件的**中介**，用于实现CPU对设备的控制，这个电子部件就是**I/O控制器**，又称**设备控制器**

##### **1. I/O控制器的功能**

- 接受和识别CPU发出的命令
    - I/O控制器中有相应的**控制寄存器**存放命令和参数
- 向CPU报告设备的状态
    - I/O控制器有相应的**状态寄存器**
- 数据交换
    - I/O控制器设置相应的**数据寄存器**，暂存数据
- 地址识别
    - 为了区分设备控制器中的各个寄存器，需要给各寄存器设置**特定的地址**，I/O控制器通过CPU提供的**地址**来判断CPU要读写的是哪个寄存器

##### 2. I/O控制器的组成

![image-20201104154856906](https://gitee.com/happy_every/note_pic/raw/master/image-20201104154856906.png)

I/O设备的组成：

1. CPU与控制器的接口(实现控制器和CPU间的通信)
2. I/O逻辑(负责识别CPU发出的命令，并向设备发出命令)
3. 控制器与设备间的接口(实现控制器与设备间的通信)

- 注意
    - 一个I/O控制器可能会对应多个设备	
    - 数据、控制、状态寄存器可能由多个，有些计算机会用这些寄存器占用内存地址的一部分，称为**内存映像**；另一些计算机采用I/O专用地址，即**寄存器独立编址**

**内存映射I/O**

控制器中的寄存器与内存同一编制

优化了指令，可以采用对内存操作的指令来对控制器进行操作

![image-20201104155405810](https://gitee.com/happy_every/note_pic/raw/master/image-20201104155405810.png)

**寄存器独立编制**

需要设置专门的指令来操作控制器，不仅去要指明寄存器地址，还需指明**控制器的编号**

![image-20201104155459407](https://gitee.com/happy_every/note_pic/raw/master/image-20201104155459407.png)

#### 2.2 I/O控制方式

##### 1. 程序直接控制方式

**keyword：轮询**

![image-20201107081930996](https://i.loli.net/2020/11/07/PG2568DsFdVOuA3.png)

**完成一次读写操作的流程**

1. CPU向控制器发出命令，将状态寄存器设为1(未就绪)
2. 将I/O状态信息读入CPU寄存器，不断轮询检查
3. 当I/O状态信息为0时，将数据寄存器中的内容读入CPU寄存器
4. 将CPU寄存器中的内容写到内存中

**CPU干预的频率**

I/O开始和结束都需要CPU介入，且在等待I/O完成的过程中CPU需要不断轮询检查

**数据传送单位**

每次读写**一个字**

**数据的流向**

每个字的读写都需要进过CPU

**优点**：实现简单，在读写指令后，加上实现循环检查的一系列指令即可

**缺点**：CPU和I/O设备只能串行工作，CPU需要一直轮询检查，长期处于忙等，CPU利用率低



##### 2. 中断驱动方式

引入中断机制，在CPU发出读写命令后，就将等待I/O的进程阻塞。当I/O完后，控制器会向CPU发出一个中断信号，CPU检查到中断信号，CPU会转去执行中断处理程序，从I/O控制器中读一个字的数据到CPU再到内存,**接着CPU恢复等待I/O的进程或其他进程的运行环境**

- CPU在每个指令周期的末尾检查中断
- 中断处理过程需要保持、恢复进程的运行环境，需要一定时间开销

**CPU干预频率**

等待I/O完成的过程中CPU可以切换到别的进程

**数据传送单位**

每次读写一个字

**数据流向**

每个字的读写都需要进过CPU

**优点**:CPU和I/O设备可以并行工作，CPU利用率明显提升

**缺点**：每次只能处理一个字，每个字都需要进过CPU(发生中断)，频繁的中断处理会消耗大量的CPU时间

##### 3. DMA

直接存储器存器(Direct Memory Access)，改进：

- 数据传送的单位是**块**

- 数据直接从内存到设备
- 仅在传送的开始和结束，才需要CPU干预

**DMA控制器**

![image-20201107084757956](https://gitee.com/happy_every/note_pic/raw/master/image-20201107084757956.png)

DR(data register):暂存从设备与内存间传送的数据

MAR(memory address register):存放数据在内存中的地址

DC(data counter):表示剩余读写的字节数

CR(command register):存放CPU发来的I/O命令，或设备的状态信息

**注意**：磁盘和DMA的DR间的数据传送还是一个字节一个字节

**CPU干预频率**

仅在开始和结束需要CPU干预

**数据传送的单位**

每次读写一个或多个块(**每次读写的只能是连续的块，写入内存后再内存中也必须是连续的**)

**数据流向**

不需要进过CPU

**优点**：CPU接入频率降低，数据传输效率提升，CPU和I/O设备的并行性得到进一步提升

**缺点**：CPU每发出一条指令，**只能读写一个或多个连续的数据块**，无法一次读取多个离散的数据块



##### 4. 通道控制方式

通道是一种**硬件**，可以识别并执行一系列通道指令，相当于弱化CPU

![image-20201107085957811](https://gitee.com/happy_every/note_pic/raw/master/image-20201107085957811.png)

**CPU干预频率**

极低，通道会根据CPU的指令执行相应的通道程序，完成一组数据块的读写后才会发出中断信号，请求CPU干预

**数据传送单位**：一组数据块

**优点**：CPU、通道、I/O设备可以并行工作，资源利用率高

**缺点**：实现复杂，需要专门的通道硬件支持

|              | 读写过程                   | CPU干预频率 | 数据传送单位 | 数据流向      |
| ------------ | -------------------------- | ----------- | ------------ | ------------- |
| 程序直接控制 | 不断轮询                   | 极高        | 字           | 设备~CPU~内存 |
| 中断驱动     | 在指令周期结束检查中断信号 | 高          | 字           | 设备~CPU~内存 |
| DMA          | 由DMA发出中断信号          | 中          | 块           | 设备-内存     |
| 通道控制     | 通道可以执行一组读写命令   | 低          | 一组块       | 设备-内存     |

### 3. I/O子系统的层次结构

![image-20201107091718458](https://gitee.com/happy_every/note_pic/raw/master/image-20201107091718458.png)

#### 3.1 用户层软件

用户层软件**实现了与用户交互的接口**，用户可直接使用该层提供的、与I/O操作有关的**库函数**对设备进程操作

#### 3.2 设备独立层软件

又称**设备无关性软件**，与设备的硬件特性无关的功能都在这一层实现

功能：

- 向上层提供统一的**系统调用接口**(如read、wirte系统调用)

- 实现设备的保护
    - 在OS中设备被看作特殊的文件
- 差错处理
- 设备的分配与回收(设备也是一种临界资源)
- 数据缓冲区管理
    - 通过缓冲区技术屏蔽设备间数据交换单位大小和传输速度的差异
- 建立逻辑设备到物理设备名的映射关系，根据**设备类型**选择调用相应的驱动程序

**设备独立性软件**需要通过**逻辑设备表LUT**，来确定逻辑设备对应的物理设备，并找到该设备对应的**设备驱动程序**

增加设备分配的灵活性、易于实现I/O重定向

![image-20201107093014465](https://gitee.com/happy_every/note_pic/raw/master/image-20201107093014465.png)

OS可以用两种方式管理逻辑设备表LUT(类似与文件的单级、二级目录)

- **整个系统只设置一张LUT**，只适用于单用户操作系统
- **为每个用户设置一张LUT**，系统在用户登入时建立一个用户管理进程，LUT存放在用户管理进程的PCB中

#### 3.3 设备驱动程序

不同设备的内部硬件特性不同，**生产者需提供与设备相对应的驱动程序**，CPU执行驱动程序的指令序列。来完成设置设备寄存器、检查设备状态等工作，**通常每类设备配置一个设备驱动程序**

将上层发出的系统调用命令转化为**对特定设备的一系列操作**

驱动程序一般会以一个独立进程的方式存在

#### 3.4 中断处理程序

当I/O完成时，I/O控制器会发送一个中断信号，系统会根据**中断信号类型**找到相应的**中断处理程序**并执行

**处理流程**

![image-20201107094056491](https://gitee.com/happy_every/note_pic/raw/master/image-20201107094056491.png)

#### 3.5 硬件

执行I/O操作，由机械部件、电子部件组成



## 5.2 I/O核心子系统

属于操作系统的内核部分即为**I/O系统**，或称**核心子系统**

### 1. I/O调度

可以使用FCFS、优先级算法、短作业算法等确定I/O调度的顺序

OS为每个设备维护一个请求队列来实现调度

### 2. 设备保护

设备被看作**特殊的文件**，OS为每个设备建立相应的FCB

### 3. SPOOLing技术

SPOOLing在用户层软件的级别

**脱机**：指脱离主机的控制进行输入输出操作，缓解设备与CPU的速度矛盾，实现预输入、缓输出

**主要目的**：提高系统资源/设备的利用率

**假脱机技术**，**用软件模拟脱机技术**，

SPOOLing将一台物理设备**虚拟**成逻辑上的多台设备，将独占设备改造成共享设备

![image-20201107101856834](https://gitee.com/happy_every/note_pic/raw/master/image-20201107101856834.png)

**输入井和输出井**：模拟脱机输入输出时的磁带

**输入进程和输出进程**：模拟脱机输入输出时的外围控制设备

**输入缓冲区和输出缓冲区**：内存中的缓冲区，输入输出时的中转站

**SPOOLing系统由预输入程序、井管理程序、缓输出程序组成**

构成SPOOLing系统的基本条件是大容量、高速度的**外存**作为输入井和输出井

进程不必等待I/O操作的完成



### 4. 设备的分配与回收

#### 4.1 设备分配概述

##### 1. 设备的固有属性

- 独占设备
- 共享设备
- 虚拟设备

##### 2. 设备的分配算法

- FCFS
- 优先级
- 短任务优先

##### 3. 设备分配中的安全性

- 安全分配方式
    - 为进程分配一个设备后就将进程阻塞，本次I/O完成后才将进程唤醒
    - 一个时间段内每个进程只能使用一个设备
    - **优点**：破坏了**保持和请求**条件，不会死锁
    - **缺点**：对于一个进程来说，CPU和I/O设备只能串行工作，进程执行效率低
- 不安全分配方式
    - 只有进程的某个I/O请求得不到满足才将进程阻塞
    - 一个进程可以同时使用多个设备
    - **优点**：进程的计算和I/O任务可以并行处理，是进程迅速推进
    - **缺点**：有可能发生死锁(需要死锁避免、死锁的检测和解除)

##### 4 . 设备分配的策略

- 静态分配
    - 进程运行前就分配其所需的全部资源，运行结束后归还
- 动态分配
    - 在进程执行中根据需要分配设备资源

### 4.2 设备分配管理中的数据结构

通道、控制器、设备间的关系

![image-20201107105607578](https://gitee.com/happy_every/note_pic/raw/master/image-20201107105607578.png)

一个通道可以控制多个设备控制器，一个设备控制器可以控制多个设备，一个系统中可以有多个通道

**设备控制表(DCT)**：系统为每个设备配置一张DCT，用于记录设备情况

![image-20201107110111356](https://gitee.com/happy_every/note_pic/raw/master/image-20201107110111356.png)



**设备类型**：指明设备的类型，打印机/扫描仪/键盘

**设备标识符**：即物理设备名，系统中每个设备的物理设备名唯一，**设备的绝对号**

**设备状态**：区分设备处于 忙碌/空闲/故障

**指向控制器表的指针**：指向相应控制器的指针

**重复执行次数或事件**：当重复多次I/O操作后仍不成功，认为此次I/O失败

**设备队列的队首指针**：指向正在等待使用该设备的进程队列(PCB队列)



**控制器控制表(COCT)**：为每个设备控制器分配一张COCT，OS根据COCT的信息对控制器进行操作和管理

![image-20201107113549459](https://gitee.com/happy_every/note_pic/raw/master/image-20201107113549459.png)

**控制器标识符**：各个控制器的ID唯一

**控制器状态**：指出控制的状态 忙碌/空西安/故障

**指向通道表的指针**：指向对应控制器的指针

**控制器队列的队首指针**：指向正在等待该控制器的进程队列

**控制器队列的队尾指针**：同上



**通道控制表(CHCT)**：每个通道对应一张CHCT，OS根据CHCT对通道进行操作

![image-20201107113958086](https://gitee.com/happy_every/note_pic/raw/master/image-20201107113958086.png)

**通道标识符**：各个通道ID唯一

**通道状态**：忙碌、空闲、故障

**与通道相连的控制器表首地址**：通过该指针找到通道管理的所有控制器信息(COCT)

**通道队列的队首指针**：指向等待通道的进程队列

**通道队列的队尾指针**：同上



**系统设备表(SDT)**：记录**系统中全部设备**的情况，每个设备对应一个表目

![image-20201107114401691](https://gitee.com/happy_every/note_pic/raw/master/image-20201107114401691.png)

#### 设备分配的步骤

1. 根据进程请求的**物理设备名**查找SDT(物理设备名是进程请求分配时提供的参数)
2. 根据有SDT找到DCT，若**设备忙碌**就将进程PCB挂到**设备等待队列**，不忙碌则分配设备给进程
3. 根据DCT找到COCT，若**控制器忙碌**就将进程PCB挂到**控制器等待队列**，不忙碌则分配**控制器**给该进程
4. 根据COCT找到CHCT，若**通道忙碌**则将进程PCB挂到**通道等待队列**，不忙碌则将**通道**分配给进程
5. 只有**设备、控制器、通道**都分配成功，这次设备分配才算成功，之后便可启动I/O设备进行数据传送

**缺点**

- 用户编程时必须使用**物理设备名**，底层细节对用户不透明
- 若更换物理设备，则程序无法运行
- 若进程请求的物理设备在忙，即使系统中还有同类型的设备，进程也必须阻塞等待

**改进**：建立逻辑设备名与物理设备名的映射机制，由OS进行管理实现

1. 根据进程请求的**逻辑设备名**查找SDT(用户编程时逻辑设备名就是**设备类型**)
2. 查找SDT找到用户进程**指定类型且空闲**的设备，将其分配给进程，OS在**逻辑设备表LUT中新增一个表项**
3. 之后操作与上面相同…

![image-20201107093014465](https://gitee.com/happy_every/note_pic/raw/master/image-20201107093014465.png)

### 缓冲区

缓冲区是存储区域，可以用专门的硬件寄存器组成，也可以用内存作为缓冲区

使用硬件作为缓冲区的成本高，容量小，一般用在对速度要求非常高的场合，如联想寄存器

一般情况下使用内存作为缓冲区，**设备独立性软件**的**缓冲区管理就是要组织管理这些缓冲区**

**缓冲区的作用**

- 缓和CPU和I/O设备间速度不匹配的矛盾
- 解决数据粒度不匹配的问题
- 减少CPU的中断频率
- 提高CPU和I/O设备的并行性



**单缓冲**

OS为进程分配一个缓冲区

 当缓冲区非空时，只能从缓冲区传出数据；不能同时传入传出

![image-20201107134557004](https://gitee.com/happy_every/note_pic/raw/master/image-20201107134557004.png)

处理一块数据平均耗时MAX(C,T)+M

**双缓冲**

OS为进程分配两个缓冲区

![image-20201107134915831](https://gitee.com/happy_every/note_pic/raw/master/image-20201107134915831.png)

处理一个数据块平均耗时**MAX(T,C+M)**

管道通信中的管道就是缓冲区，要实现数据的双向传输，必须设置两个管道



**循环缓冲区**

将多个大小相等的缓冲区连接成一个循环队列

in指针指向下一个可以冲入数据的空缓冲区

out指针指向下一个可以取出数据的满缓冲区

![image-20201107135344296](https://gitee.com/happy_every/note_pic/raw/master/image-20201107135344296.png)

**缓冲池**

缓冲池由系统中共用的缓冲区组成

- 空缓冲队列
- 输入队列(装满输入数据的缓冲队列)
- 输出队列(装满输出数据的缓冲队列)

![image-20201107135853818](https://gitee.com/happy_every/note_pic/raw/master/image-20201107135853818.png)

四种工作缓冲区

- hin：用于收容输入数据的工作缓冲区
- sin：用于提取输入数据的工作缓冲区
- hout：用于收容输出数据的工作缓冲区
- sout：用于提取输出数据的工作缓冲区

![image-20201107135930908](https://gitee.com/happy_every/note_pic/raw/master/image-20201107135930908.png)

四种操作

- 输入进程请求输入数据
    - 从空缓冲队列取出缓冲区，到hin工作缓冲区来输入进程的数据，然后挂到输入队列的队尾
- 计算进程想要取得一块输入数据
    - 从输入队列取得一块输入缓冲区，到sin来提取输入，然后挂到空缓冲队列队尾
- 计算进程想要将准备好的数据冲入缓冲区
    - 从空缓冲区队列取得缓冲区，到hout收容输出，挂到输出队列队尾
- 输出进程请求输出数据
    - 从输出队列取得输出缓冲区，到cout提取输出，挂到空缓冲队列队尾