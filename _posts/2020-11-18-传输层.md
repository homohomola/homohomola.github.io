---
layout:     post
title:      传输层
subtitle:   TCP/IP第4层
date:       2020-11-18
author:     sakura
header-img: img/the-first.png
catalog: true
tags:
    - 计算机网络
---

# 5 传输层

任务：**为运行在不同主机上的应用进程(AP)提供直接的通信服务是传输层的任务**，又称端到端协议

**功能**

- 实现端到端的通信，提供进程间的逻辑通信

- 差错检测
- 提供 无/面向 连接的服务
    - 对于面向连接服务
        - 连接管理
        - 流量控制与拥塞控制
- 复用和分用

## 5.1 传输层协议概述

### 5.1.1 端口号

**在传输层按端口号寻址，此端口是软件端口，软件端口是应用层各种协议进程与传输实体进行层间交互的地址**，硬件端口是不同设备交互的物理接口。

运行在计算机上的进程使用**进程标识符PID**来标志，不同的操作系统使用**不同格式的进程标识符**，为使**不同操作系统**的进程能相互通信，就必须使用同一的方法(**端口号**)对应用进程标识

- 端口号使用16位表示，取值范围0~65535
- 服务器 端口号 0 ~ 49151
    - 熟知端口号 0~1023
        - 常见：FTP 21/20; HTTP 80; DNS 53
    - 登记端口号 1024 ~ 49151
- 客户端 端口号 49152~65535
    - 仅在客户进程运行时才动态选择，又称短暂端口号

**端口号仅标识本主机进程，对于不同主机可以有相同端口号**

### 5.1.2 分用和复用

![image-20201017090751583](https://gitee.com/happy_every/note_pic/raw/master/image-20201017090751583.png)

### 5.1.3 套接字socket

一台拥有IP地址的主机可以通过多种服务

端口号套接到IP地址即为套接字

套接字 = （主机IP地址 ， 端口号）

**套接字唯一标识了网路上某主机的某个进程**

## 5.2 用户数据报UDP

### 5.2.1 特点

支持单播多播广播

UDP使面向报文的：对应用层报文不合并也不拆分

UDP向上层提供无连接不可靠服务(无连接无确认)

报文头部短，传输开销小，时延短(适用于实时应用)，不需要维持复杂的连接状态表

网络拥塞不会使源主机的发送速率降低

### 5.2.1 UDP首部格式+++

![image-20201017091718137](https://gitee.com/happy_every/note_pic/raw/master/image-20201017091718137.png)

- 源端口 2B：需要回信时使用，不需要则全零
- 目的端口号 2B
- 长度 2B：UDP，一般UDP限制应用程序数据为512B或更小
- 校验和 2B：检验UDP数据报是否出错，可选字段，源主机不想计算校验和时，该字段全0

### 5.2.3 UDP校验

计算校验和前，先加上 12B 的伪首部，伪首部包括

- 源IP地址
- 目的IP地址
- 全0字段 和 协议字段(UDP固定为17)
- UDP长度

**检验时，若UDP数据报数据部分长度不是偶数字节，则填入一个全0字节(不发送，只用于校验)**

将UDP进行反码运算求和，将结果求反码得到校验和

接收方也需填入**伪首部和填充字节(自行填充)**，反码求和，结果为全1则说明无错



## 5.3 传输控制协议TCP+++++

只支持单播，每条TCP连接只能有两个端点(**套接字**)，点对点

TCP面向字节流：TCP把数据看作是**无结构的字节流**，保证收发双方的字节流**完全一样**

![image-20201018115019865](https://gitee.com/happy_every/note_pic/raw/master/image-20201018115019865.png)

TCP向上层提供面向连接的可靠服务，提供全双工通信，TCP两端都设有发送和接收缓存

**每一条TCP接连唯一被通信两端的两个端点(套接字)确定**

TCP连接 ::= { $socket_1$,$socket_2$}={ ( $IP_1:port_1$), ($IP_2:port_2$)}



### 5.3.1 TCP流量控制

利用**滑动窗口机制**实现对**发送方**的流量控制

- 接收方利用自己的**接受窗口**大小来限制**发送窗口**的大小
- 发送方收到接收方的**零窗口通知**后，启动**持续计时器**，超时重发**零窗口探测报文**
- 接收方一般采用**累计确认**

### 5.3.2 TCP拥塞控制

若出现拥塞而不进行控制，整个网络的吞吐量将随输入负荷增大而下降，最终导致死锁(吞吐量为0)

- 发送方维护一个**拥塞窗口cwnd**的状态变量，其值取决于网络的拥塞程度，且动态变化
    - **cwnd**维护原则：只要网络没有出现拥塞，**cwnd**就增大一些；出现拥塞，则减少一些
    - 判断**网络拥塞**的依据：没有按时收到确认报文(**超时重传**)
- 发送方将拥塞窗口cwnd作为**发送窗口swnd**，即**swnd=cwnd**
- 发送方维护一个慢开始门限**ssthresh**状态变量
    - 当cwnd<ssthresh时，使用慢开始算法slow-start
    - 当cwnd>ssthresh时，改用拥塞避免算法
    - 当cwnd=ssthresh时，二者都可使用



**TCP拥塞控制算法（TCP Tahoe版本）**

#### 1.  慢开始

**慢开始指一开始向网络注入报文段少，并非cwnd增长慢**

每个传输轮次结束后，cwnd指数级增加（每次*2），直到到达门限ssthresh

#### 2.  拥塞避免

**拥塞避免并非能完全避免拥塞，而是将拥塞窗口控制为线性增长，使之不容易出现拥塞**

每个传输轮次结束后，cwnd线性+1

当重传计时器超时，判断网络发生故障：

- 将**ssthresh**值，更新为发生拥塞时swnd值的一半
- 将**cwnd**值减少为1，重新执行慢开始算法

---

**TCP控制算法**（TCP Reno版）

对于个别报文段丢失，但网络并未发生拥塞的情况下，发送方会错误地启动慢开始算法。

使用快重传算法，可以让发送发尽早知道发生个别报文段丢失

- 使发送方**尽快进行重传**，而不是**等待超时重传计时器超时**再重传
    - 要求接收方不要等待自己发送数据才进行捎带确认，而是**立即发送确认**
    - 即使收到失序的报文段也立即发出**重复确认**
    - 发送发一旦收到**三个连续的重复确认**，就**立即重传**相应报文段

#### 3. 快重传

- 发送方连续发送多个报文段，接收方收到报文段后，立即发回确认

- 遇到报文段丢失，发送方继续接收之后的报文端，每次发回对丢失报文段前的确认

- 接收方收到三次重复确认后，立即重传相应报文段

#### 4. 快恢复

**对于收到三个重复确认后：**

**发送方将ssthresh值和cwnd值调整为当前窗口一半**

或则将cwnd增大，cwnd=ssthresh+3，理由为已经有三个报文离开网络(三个重复确认)

![image-20201018092419247](https://gitee.com/happy_every/note_pic/raw/master/image-20201018092419247.png)



### 5.3.4 TCP超时重传时间选择

超时重传RTO应略大于往返时间RTT

利用每次测量得的RTT样本，计算加权平均往返时间$RTT_S$  和RTT偏差的加权平均$RTT_D$`



$RTO = RTT_S + 4 * RTT_D$



$新的RTT_S = (1-α) * 旧的RTT_S + α * 新的RTT样本$$0 \le a \le 1,建议值为1/8$

$新的RTT_D=(1-β)*旧的RTT_D+β*|RTT_S-新的RTT样本|$

$0 \le β  <  1,建议值为1/4 ,RTT_{D1}=RTT_1/2$



对于超时重传时无法准确测量RTT时，使用Karn算法：再计算$RTTS_S$时，只要重传就不计算RTT样本。

但如果报文段时延突然增大很多，且一直保持高时延的情况下，根据Karn算法，超时重传时间无法更新，会导致报文段反复被重传

所以要对**Karn算法进行修正**，没重传一次，就把RTO增大一些(通常是*2)

### 5.3.5 TCP可靠传输

TCP以**字节为单位的滑动窗口**来实现可靠传输

前沿是发送窗口的最前端，发送窗口最后一个发送的数据



**使用三个指针来描述发送窗口的状态**

p1指向发送窗口后沿的字节序号

p2指向最后已发送的下一个字节序号

p3指向发送窗口前沿下一个字节序号

![image-20201018095949685](https://gitee.com/happy_every/note_pic/raw/master/image-20201018095949685.png)



- 同一时刻，发送方和接收方的窗口大小并不一致
    - 网络传输窗口值有时间滞后
    - 发送方会根据网络拥塞适当减小窗口
- 对于**不按序到达的数据如何处理**，TCP并无明确规定
    - TCP通常对不按序到达的数据临时存放再接收窗口中，等字节流中缺失的字节收到后，再按序交付上层的进程
- TCP要求接收方必须有累计确认和捎带确认机制
    - 接收方不应过分推迟发送确认，确认推迟不应超过0.5秒
    - 捎带确认实际上并不经常发生，大多数进程很少同时在两个方向上发送数据
    - 接收方对已接受且按序到达的最后一个报文确认

### 5.3.6 TCP运输连接管理

#### 1. TCP连接建立

1. TCP服务器进程首先创建**传输控制块**，存储TCP重要连接信息
    - 如TCP连接表
    - 指向发送和接受缓存的指针
    - 指向重传队列的指针
    - 当前的发送和接收序号等
2. TCP服务器进程有CLOSE关闭状态进入LISTEN监听状态，等待TCP客户进程的连接请求(被动打开连接)
3. TCP客户进程首先创建**传输控制块**，在打算建立TCP连接时，向TCP服务器进程发送**TCP连接请求报文段**，TCP客户进程进入SYN-SENT同步已发送状态 ，报文段同步位**SYN**设置为1，**seq**设置初始值x(作为客户进程初始序号)**SYN为1的字段不携带数据但要消耗一个序号**

4. 服务器进程收到请求报文段后，如同意建立连接，则发送**TCP连接请求确认报文段**，进入SYN-RCVD同步已接收状态，SYN设置1，确认位ACK设置1，seq设置y(服务进程初始序号，**此值可由服务器随意指定，与其他报文段值无关**)，ack=x+1(对客户初始序号的确认)
5. 客户进程收到确认报文段后，还要发送**普通的TCP确认报文段**，进入ESTABLISHED连接已建立状态，ACK=1(表明为普通确认报文段)，seq=x+1(**TCP规定普通的确认报文段可以携带数据，如果不携带数据，则不消耗序号，因此下一个数据报文序号还是x+1**)，ack=y+1(对服务器进程初始序号的确认)
6. TCP收到确认报文段后也进入ESTABLISHED连接已建立状态，双方都进入ESTABLISHED连接已建立状态，TCP连接建立

![image-20201018105602898](https://gitee.com/happy_every/note_pic/raw/master/image-20201018105602898.png)

**三报文握手是为了防止已失效的连接请求报文突然又传送到TCP服务器**，导致TCP服务器资源浪费。



#### 2. TCP连接释放

1. 客户进程发送**TCP连接释放报文段**，进入FIN-WAIT-1 终止等待1状态，FIN=1,ACK=1,seq=u(u为客户进程上一个传输数据最后一个序号加一，**TCP规定FIN为1的字段，即使不携带数据也要消耗一个序号**)，ack=v(**为客户收到字节序号加一**)
2. 服务器进程收到后，会发送**普通的TCP确认报文段**，并进入CLOSE-WAIT状态，ACK=1，seq=v(为服务器进程已传送的最后一个字节序号加一)，ack=u+1(对释放报文段的确认)。通知高层进程，客户要断开连接。此时，从**客户进到服务器方向的连接就释放了(单方向)**,TCP连接处于半关闭状态,客户进程没有数据要发送。但从**服务器到客户方向**的连接并未关闭
3. 客户进程收到TCP确认报文后进入FIN-WAIT-2 终止等待2状态，等待服务器进程发出**TCP连接释放报文段**，此时客户端还需接受服务器进程发来的数据
4. 如果**服务器进程**没有数据要发送，服务进程发送**TCP连接释放报文段**进入LAST-ACK最后确认状态，FIN=1,ACK=1,seq=w(服务器在关闭等待期间可能又发送些数据)，ack=u+1(对之前收到的TCP连接释放报文段的重复确认)
5. 客户进程接受后发送**普通的TCP确认报文段**，进入TIME-WAIT时间等待状态，ACK=1,seq=u+1，ack=w+1
6. 服务器进程收到后就进入CLOSE关闭状态
7. 客户端经过两倍MSL后才能进入CLOSE关闭状态，MSL为**最长报文寿命**，防止TCP确认报文段丢失，导致服务器进程超时反复重传，消耗服务器资源；使本次产生的报文段在网络中消失，使新TCP连接中不会出现旧连接中的报文段

![image-20201018114729788](https://gitee.com/happy_every/note_pic/raw/master/image-20201018114729788.png)

**TCP保活计时器**

- 服务器进程每收到一次客户进程的数据，就重新设置并启动**保活计时器**(2小时定时)
- 保活计时器到期后，服务器进程就向客户进程发送**探测报文段**，每隔75秒发送一次，若连续10次后仍无客户进程响应，服务器就认为客户进程所在主机发送故障，关闭连接

### 5.3.7 TCP首部格式

TCP发送数据时，是从发送缓存中取出一部分或全部并添加一个首部使之成为TCP报文段



![image-20201018115054171](https://gitee.com/happy_every/note_pic/raw/master/image-20201018115054171.png)

- 源端口：16位，标识发送TCP报文段的进程

- 目的端口：16位，标识接受TCP报文段的进程

- 序号：32位，取值 0~  $2^{32}-1$,序号增加到最后一个后，下一个序号回到0，**指出本TCP数据载荷的第一个字节的序号**
- 确认号：32位，取值 0~  $2^{32}-1$,序号增加到最后一个后，下一个序号回到0，**指出希望收到对方下一个TCP报文段的数据载荷的第一个字节的序号，同时也是对之前收到数据的确认**
- 确认标识位ACK：取值为1时，确认号字段有效；0则无效。**连接建立后，所有TCP报文段的ACK必须为1**
- 推送标识位PSH：接受方收到PSH=1的报文会**尽快上交应用进程**，而不必等待接收缓存慢后向上交付
- 复位标志位RST：复位TCP连接，当RST=1时，表明TCP连接出现异常，必须释放连接，然后重新建立连接。此外，RST置1，还可拒绝一个非法报文段或拒绝打开一个TCP连接
- 同步标志位SYN：在TCP连接建立时用来同步序号
- 终止标识位FIN：释放TCP连接
- 数据偏移：4位，以4字节为单位，**实际指出TCP报文段的首部长度**，取值0101~1111（20字节到60字节）
- 保留：6位，保留为今后使用，目前置为0
- 窗口：16位，以字节为单位，**指出发送本报文段的接受窗口**，让发送方设置发送窗口的依据
- 校验和：16位，检测TCP首部和数据载荷，计算时需加上12字节的伪首部

- 紧急标识位URP：UPG=1时，紧急指针字段有效；0则无
- 紧急指针：16位，UPG=1时，指明紧急数据的长度，当发送方又紧急数据，可将紧急数据插队到发送缓存的最前面，并立刻封装到TCP报文段中发送。紧急指针指出本报文段数据载荷部分包含紧急数据的长度，之后是普通数据



选项（长度可变）

- 最大报文段长度MSS：TCP报文数据载荷最大长度
- 窗口扩大：提高吞吐率
- 时间戳
    - 计算RTT
    - 处理序号超范围的情况
- 选择确认
- 填充：确保报文段首部为4字节的整数倍