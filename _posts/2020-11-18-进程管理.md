---
layout:     post
title:      OS进程管理
subtitle:   进程如何被管理
date:       2020-11-18
author:     sakura
header-img: img/the-first.png
catalog: true
tags:
    - 操作系统

---

## 2.1 进程

### 1. 进程的定义

**对于单道程序处理技术**：

程序：一个指令序列 

![image-20201025083151155](https://gitee.com/happy_every/note_pic/raw/master/image-20201025083151155.png)

程序代码放在程序段(低地址)，需要处理的数据放在数据段(高地址)

**引入多道程序技术后**：

![image-20201025083826608](https://gitee.com/happy_every/note_pic/raw/master/image-20201025083826608.png)

**PCB、程序段、数据段**构成了**进程实体(进程映像)**

OS为每个运行的程序配置一个数据结构——进程控制块PCB，来描述进程的各种信息

**PCB是进程存在的唯一标志**，**进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位**

### 2. PCB的组成

---

#### 2.1 进程描述信息

##### 1.  进程标识符

当进程被创建时，操作系统会为该进程分配一个唯一的、不重复的ID，区分不同的进程

##### 2. 用户表示符

---

#### 2.2 进程控制和管理信息

进程当前状态

进程优先级

#### 2.3 资源分配清单

程序段指针

数据段指针

键盘

鼠标

#### 2.4 处理机相关信息

各种寄存器值

---



### 3. 进程的组织方式

#### 3.1 链接方式

按进程状态将PCB分为多个队列，OS持有指向各队列的指针

#### 3.2 索引方式

根据进程状态不同，建立索引表，OS持有指向索引表的指针

---



### 4. 特征

#### 4.1 动态性

进程时程序的一次执行过程，是动态地产生、变化和消亡的

是进程最基本的特征

#### 4.2 并发行

内存中由多个进程实体，各进程可并发执行

#### 4.3 独立性

进程能**独立 运行、获得资源、接收调度 的基本单位**

#### 4.4 异步性

各进程按各自独立的、不可预知的速度向前推进，操作系统要提供“进程同步机制”来解决异步问题

可能导致运行结果的不确定性

#### 4.5 结构性

每个进程都会配置一个PCB，结构上看，进程由程序段、数据段、PCB组成

---



### 5. 进程的状态

#### 5.1 运行态

占有CPU，并在CPU上运行

#### 5.2 就绪态

已具备运行状态，但由于没有空闲CPU，而暂时不能运行

进程已经拥有了除处理机外所有需要的资源，一旦获得处理机，即可进入运行态

#### 5.3 阻塞态

因等待某一事件而暂时不能运行，比如I/O设备资源

阻塞态下进程**不占用CPU和其他所需资源**

#### 5.4 创建态

进程正在被创建，OS为进程分配资源、初始化PCB

#### 5.5 终止态

进程正在从OS中撤销，OS会回收进程拥有的资源、撤销PCB

#### 5.6 状态的转化

![image-20201025092337542](https://gitee.com/happy_every/note_pic/raw/master/image-20201025092337542.png)

---



### 6. 进程控制

---

#### 6.1 进程控制的实现

进程控制就是实现进程状态的转化，通过OS对PCB创建、修改、撤销和对资源的分配回收来实现

使用**原语**来实现进程控制，原语的特点是执行期间**不允许中断**

原语采用**<u>关中断指令</u>和<u>开中断指令</u>**来实现

执行了关中断指令后，忽略外部中断信号，直到开中断指令执行后，保证了原语代码的**原子性**

##### 1. 更新PCB信息

- 所有的进程控制原语一定会**修改进程状态标志**
- 剥夺当前运行进程的CPU使用权，必须**保存运行环境**
- 在进程开始运行前**恢复运行环境**

##### 2. 将PCB插入合适的队列

##### 3. 分配/回收资源

---

#### 6.2 进程控制的原语

##### 1. 进程的创建

允许一个进程创建另一个进程，此时创建者称为**父进程**，被创建的进程称为**子进程**。子进程继承父进程的所有资源，子进程被撤销时，归还所有资源给父进程；在撤销父进程是，必须同时撤销所有子进程

在OS中，终端用户登录系统、作业调度、系统提供服务、用户程序的应用请求都会引起进程的创建

OS创建新进程的过程如下(创建原语)：

1. 为新进程分配一个唯一的进程标识符，并申请一个空白PCB，若PCB申请失败，则穿件失败
2. 为进程分配资源，为新进程的程序和数据及用户栈分配内存空间(若资源不足，则进入阻塞态)
3. 初始化PCB，初始化标志信息、处理机状态、处理机控制信息等
4. 若进程就绪队列能接收新进程，则将新进程插入就绪队列，等待被调度

##### 2. 进程的终止

撤销原语：

1. 根据被终止进程的标识符，检索PCB，读出进程状态
2. 若进程处于执行状态，则终止运行
3. 若有子进程，将所有子进程终止
4. 归还资源给OS或父进程
5. 将PCB从所在队列删除

##### 3. 进程的阻塞和唤醒

进程的阻塞和唤醒要成对出现

##### 5. 进程的切换

任何进程的切换都是在OS内核的支持下运行的

切换原语：

1. 保持处理机上下文，包括程序计数器和其他寄存器
2. 更新PCB信息
3. 将进程的PCB移入相应队列
4. 选择另一个进程执行，更新其PCB
5. 更新内存管理的数据结构
6. 恢复处理机上下文

与处理机模式不同在于，处理机模式切换无须改变当前运行环境

---



### 7. 进程的通信

> 进程通信就是进程间的信息交换

进程是分配系统资源的单位(包括地址空间)，因此进程拥有的**内存地址空间相互独立**，为保证安全，**进程不能直接访问其他进程的地址空间**，但信息交换是必须实现的，为了保证安全通信，由OS提供方法

---

#### 7.1 共享储存

![image-20201025102455227](https://gitee.com/happy_every/note_pic/raw/master/image-20201025102455227.png)

两个进程对共享空间的访问是**互斥**的(通过OS提供的同步互斥工具实现)，OS只提供共享空间可互斥工具

##### 1.基于数据结构的共享

如共享空间里只能放一个长度为10的数组，这种共享方式速度慢、限制多，是一种**低级通信**方式

##### 2.基于存储区的共享

数据的形式、存放位置都由进程控制，而不是OS，这种方式速度更快，是一种**高级通信**方式

---

#### 7.2 消息传递

进程间的数据交换以**格式化的消息**(Message)为单位，进程通过OS提供的“发送/接收 消息”两个**原语**进行数据交换

消息分为消息头和消息体

消息头包括：发送进程ID、接收进程ID、消息类型、消息长度等格式化信息

##### 1. 直接通信方式

消息直接挂到接收进程的消息缓冲队列上

##### 2. 间接通信方式

消息要先发送到中间实体(信箱)，也称信箱通信方式

---

#### 7.3 管道通信

![image-20201025102424794](https://gitee.com/happy_every/note_pic/raw/master/image-20201025102424794.png)

**管道**：用于连接读写进程的**一个共享文件**，又名pipe文件，就是在内存中开辟一个大小固定的**缓冲区**

1. 管道只能采用**半双工通信**，如要实现双向同时通信，需要设置两个管道

2. 各进程**互斥**地访问管道

3. 数据以字符流的形式写入，当**管道写满**时，**写进程**的wirte()系统调用江北**阻塞**，等待读进程将数据取走；当读进程将数据全部取走后，管道变空，此时**读进程**的read()系统调用将被阻塞
4. 如果**没写满，就不许读；没读空，就不许写**
5. 数据一旦被读出，就从管道中抛弃，意味着最多**只能有一个读进程**，否则可能会读错数据

---



### 8. 线程

![image-20201025104511148](https://gitee.com/happy_every/note_pic/raw/master/image-20201025104511148.png)

有的进程可能需要“同时”处理很多事，传统的进程只能串行地执行一系列程序。因此，引入线程，增加并发度，各线程间也能并发

**变化：**

- 引入线程后，线程成为**程序执行流的最小单位，也是基本的CPU执行单元** 

- **进程**只作为**除CPU外的系统资源的分配单元**，如内存、打印机都是分配给进程的；线程时**调度的基本单位**

- 线程间并发，线程切换不需要切换进程环境，系统开销小

---

#### 8.1 线程的属性

- 线程时处理机调度的单位
- 多CPU计算机，各线程可占用不同的CPU
- 每个线程都有一个线程ID、线程控制块TCB
- 线程也有就绪、阻塞、运行三种状态
- 线程几乎不拥有系统资源，不同线程共享进程的资源
- 同一进程的线程通信无需系统干预；线程切换也不会引起进程切换

#### 8.2 线程的实现方式

##### 1. 用户级线程

用户级线程由应用程序通过线程库实现，所有**线程管理工作**由**应用程序负责**(包括线程切换，在用户态下即可完成)

用户级进程对操作系统透明

![image-20201025105759167](https://gitee.com/happy_every/note_pic/raw/master/image-20201025105759167.png)

##### 2. 内核级线程

内核级线程的管理工作由OS内核完成，内核级线程的切换必须在**核心态**下能完成

![image-20201025105950398](https://gitee.com/happy_every/note_pic/raw/master/image-20201025105950398.png)

对于同时支持用户级线程和内核级线程的系统中，可采用将 n 个用户线程映射到 m 个内核级线程上($n \ge m$ )

![image-20201025110321171](https://gitee.com/happy_every/note_pic/raw/master/image-20201025110321171.png)

**内核级线程才是处理机分配的单位**

---

#### 8.3 多线程模型

##### 1. 多对一模型

多个用户线程映射到一个内核级线程

**优点**：用户级线程切换在用户空间即可完成，不需要切换到核心态，线程管理系统开销小，效率高

**缺点**：当一个用户级进程被阻塞后，整个进程都会被阻塞，并发度不高；多个线程不能在多核处理机上并发运行

##### 2. 一对一模型

**优点**：并发能力强，多线程可在多核CPU处理及上并发执行

**缺点**：一个用户进程会占用多个内核级线程，线程切换由OS内核完成，需要切换到核心态，线程管理成本高，开销大

##### 3. 多对多模型

结合二则的优缺点

---



## 2.2 处理机调度

### 1. 基本概念

---

#### 1.1 调度层次

##### 1.高级调度

**高级调度(作业调度)**，按一定原则从外存中处于后备队列的作业中挑选一个或多个作业，分配内存等必要资源，并建立**相应进程(PCB)**，以使它们获得**竞争处理机的权力**

高级调度是外存与内存间的调度，每个作业只调入一次，调出一次。作业调入时建立PCB，调出时撤销PCB



##### 2. 中级调度

**中级调度(内存调度)**：决定将哪个处于挂起状态的进程重新调入内存

引入了虚拟存储技术之后，可将暂时不能运行的进程调至外存等待。等重新具备了运行条件且内存有空闲时，在重新调入内存

**目的**：提高**内存利用率**和**系统吞吐量**

暂时调到外存等待的进程状态称为**挂起状态**，PCB不会调到外存，而是**常驻内存**，记录进程数据在外存中的存放位置、进程状态等信息

被挂起的进程PCB会被放到**挂起队列**中，一个进程可能会被多次调入调出内存，中级调度发生频率高于高级调度



###### 补充知识

挂起态可进一步分为**就绪挂起**、**阻塞挂起**两种状态

![image-20201025130143516](https://gitee.com/happy_every/note_pic/raw/master/image-20201025130143516.png)

挂起时将进程映像调到外存中(内存不够，就放外存)



##### 3.低级调度

**低级调度(进程调度)**：安装某种方法和策略从**就绪队列**中选取进程，分配处理机

进程调度是OS中**最基本的调度**，OS必须配置进程调度

进程调度频率很高，几十毫秒一次



##### 4. 三层调度

|          |             do what              | where                 | 频率 | 对进程状态的影响                  |
| :------: | :------------------------------: | --------------------- | ---- | --------------------------------- |
| 作业调度 | 从后背队列选择合适的作业调入内存 | 外存->内存（面向作业) | 低   | 无->创建态->就绪态                |
| 内存调度 |        从挂起队列调回内存        | 外存->内存(面向进程)  | 中   | 挂起态->就绪态（阻塞挂起->阻塞态) |
| 进程调度 |   从就绪队列选择进程分配处理机   | 内存->CPU             | 高   | 就绪态 ->运行态                   |



---

### 2. 进程调度时机

#### 2.1 切换时机

##### 1.进程主动放弃处理机

- 进程正常终止
- 运行过程中发送异常而终止
- 进程主动请求阻塞

##### 2. 进程被动放弃

- 时间片用完
- 有更紧急的事需要处理(I/O中断)
- 有更高优先级进程进入就绪队列

#### 2.2 不能切换的情况

- 处理中断过程中
- 进程在**操作系统内核临界区**中
- 在原子操作过程中(原语)

**临界资源**：一段时间内只允许一个进程使用的资源，各进程**互斥**地访问临界资源

**临界区**：访问临界资源的代码

**内核临界区**一般用来访问**某种内核数据结构**，如进程的就绪队列(由就绪进程的PCB组成)

访问内核数据结构时会加上锁，如不及时释放会影响内核其他管理工作，所以不能进行调度和切换(**赶紧运行完释放资源**)

而对于普通临界区资源的占用不会直接影响内核的管理工作，可以进程调取(**多占资源点时间也没关系**)

---

### 3. 进程调度方式

#### 3.1 非抢占方式

又称非剥夺式调度方式，只允许进程主动放弃处理机

实现简单，系统开销小但是无法及时处理紧急任务，适合早期批处理系统

#### 3.2 抢占方式

又称剥夺调度方式，可以优先处理更紧急的任务，也可实现按时间片轮流执行的功能(通过时钟中断)，适合分时操作系统、实时操作系统

---

### 4. 进程的切换与过程

**狭义**的**进程调度**，指从就绪队列中选中一个进程

**进程切换**指一个进程让出处理及，另一进程占用处理机的过程

**广义**的**进程调度**包含了进程调度和进程切换，需要联系上下文分析

进程切换过程：

- 对原进程数据的保存(保存在PCB)
- 对新进程数据的恢复(从PCB恢复)

**进程的切换是有代价的**，过于频繁的切换、调度进程，会使整个系统效率降低

---

### 5. 调度算法的评价指标

#### 5.1 CPU利用率

$利用率=\frac{忙碌时间}{总时间}$

#### 5.2 系统吞吐量

$系统吞吐量=\frac{完成作业数}{总共时间}$

#### 5.3 周转时间

指作业**被提交给系统**开始，到**作业完成**的时间间隔

(作业)周转时间 = 作业完成时间 - 作业提交时间

**平均周转时间** = `$\frac{各作业周转时间和}{作业数}$`

**带权周转时间** = `$\frac{作业周转时间}{作业实际运行时间}$`

**平均带权周转时间** = （各作业带权周转时间和）  /  （作业数）

#### 5.4 等待时间

指进程/作业处理等待处理机状态时间之和，在等待I/O完成期间，进程被设备服务，不计入等待时间

对于作业还要加上作业在外存后备队列的等待时间

平均等待时间 = （等待时间和）   /  （作业数）

#### 5.5 响应时间

指用户提交请求到首次产生响应的时间

---

### 6.  调度算法

学习思路：

- 算法思想
- 算法规则
- 用于 作业 or 进程 角度
- 抢占式？非抢占式？
- 优缺点
- 是否导致**饥饿**

#### 6.1 FCFS 先来先服务

- 从公平的角度考虑
- 按作业、进程到达的先后顺序进行服务
- 非抢占式
- 优点：公平、实现简单
- 缺点：在长作业后的短作业的带权周转时间很大，对**长作业有利，对短作业不利**
- 不会导致饥饿

#### 6.2 SJF 最短作业优先

- 追求最少的平均 等待/周转/带权周转 时间
- 最短的作业、进程优先服务
- 用于进程角度时称为**最短进程优先SPF**算法
- SJF和SPF是非抢占式算法，但有抢占式版——**SRTN最短剩余时间优先算法**
    - **SRTN**:当有新进程加入就绪队列时就需要调度，比较进程的剩余时间，短的进程抢占处理机
- 优点：最短的平均时间
- 缺点：不公平，对**短作业有利，对长作业不利**，作业/进程的运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先
- 会导致饥饿

#### 6.3 HRRN 高响应优先

- 综合考虑作业、进程的等待时间和要求服务的时间
- 每次调度时先计算各个作业、进程的**响应比**，选择**响应比最高**的作业、进程
    - **响应比=（等待时间+要求服务时间）/（要求服务时间）**

- 非抢占式

- 优点：对于长作业随着等待时间的增加，响应比也会增加，避免了饥饿问题



以上算法适用于早期批处理系统，只关心系统整体性能指标，不关心响应时间与任务紧急度，交互性糟糕



#### 6.4 时间片轮转RR(Round-Robin)

- 公平、轮流为进程服务
- 按照到达就绪队列顺序，轮流让各进程执行一个时间片；未执行完的进程剥夺处理机，重新进入就绪队列
- 用于进程调度(只有**作业进入内存 建立进程**才能被分配处理机时间片)
- 抢占式，由时钟装置发出**时钟中断**通知CPU时间片已到
- 时间片太大，会退化为FCFS算法，增加响应时间；时间片太小，会导致频发调度、切换，增加系统开销
- 优点：公平、响应快，适合分时操作系统
- 缺点：增加开销、不区分任务紧急程序
- 不会导致饥饿

#### 6.5 优先级调度算法

Priority Schedling

- 越来越多的应用场景需要根据任务紧急程度来决定处理顺序
- 调度时选择**优先级最高**的作业、进程
- 可用于作业、进程调度，以及**I/O调度**
- 抢占式、非抢占式都有，看是否在就绪队列变化时，检查是否发生抢占
- 优点：适用于实时操作系统，可灵活调整对各作业、进程的偏好程度
- 缺点：若由源源不断的高优先级进程到来，可能导致饥饿



根据优先级是否可以动态变化，可将优先级分为**静态优先级和动态优先级**两种

通常：系统进程优先级高于用户进程；前台进程优先级高于后台进程；操作系统更**偏好I/O型进程**（而不是**计算型进程**），优先让I/O设备投入工作，资源利用率、系统吞吐量都会得到提升

#### 6.6 多级反馈队列调度算法

- 对其他调度算法的折中权衡
- 用于进程调度
- 抢占式算法
- 优缺点
    - 对各类进程相对公平(FCFS)
    - 每个新到达的进程都可以很快就得到响应(RR的优点)
    - 短进程只用较小的时间就可以完成(SPF的优点)
    - 不必实现估计进程的运行时间(避免用户作假)
    - 可灵活调整对各类进程的偏好程度(将因I/O而阻塞的进程重新放回到原队列)
    - 会导致饥饿

**算法规则**

1. 设置多级就绪队列，各队列优先级从**高到低**，时间片从从**小到大**

2. 新进程到达时先进入第一级队列，按FCFS原则排队等待被分配时间片。若时间片用完，进程未结束，则进入下一级队列队尾。如已在最下级队列，则放回队尾
3. 只有第K级队列为空时，才会为K+1级队头进程分配时间片
4. 被抢占处理机的进程重新放到原队列队尾



以上三种算法注重系统的响应时间、公平性、平衡性等指标，也满足了交互式系统的需求(UNIX使用的就是多级反馈队列调度算法)

---



## 2.3 进程同步

---

### 1. 基本概念

#### 1.1 进程同步

并发性带来异步性，进程具有**异步性**，各并发执行的进程以各自独立的、不可预知的速度向前推进

有些进程需要互相配合完成工作，各进程的工作推进需要遵循一定的先后顺序

#### 1.2 进程互斥

进程的并发需要共享的支持，各个并发执行的进程不可避免的需要共享一些系统资源

两种资源共享方式：**互斥共享方式**、同时共享方式(允许一个时间段由多个进程“同时”访问资源)

**临界资源**：一个时间段内只允许一个进程使用的资源，如摄像头、变量和数据缓的冲区

**进程互斥**：一个进程访问某临界资源时，另一个想访问资源的进程必须等待

##### 1. 四个部分

```c
//对临界资源的互斥访问，可在逻辑上分为
do{
    entry    	section;	//进入区
    critical 	section;	//临界区
    exit     	section;	//退出区
    remainder   section;	//剩余区
}while(true)
```

- 进入区	负责检查是否课进入临界区，若可，则设置<u>正在访问临界资源标志(**上锁**)</u>
- 临界区	访问临界资源的代码

- 退出区	负责解除<u>正在访问临界资源的标志(**解锁**)</u>

- 剩余区	做其他处理

**临界区**是进程中访问临界资源的**代码段**，进入和退出区是负责实现互斥的代码段。

##### 2. 互斥访问原则

1. 空闲让进
2. 忙则等待
3. 有限等待：有限时间内进入临界区，保证不会饥饿
4. 让权等待：进不了临界区的进程，要释放处理机

---

### 2. 进程互斥的实现方法

#### 2.1 软件实现

##### 1. 单标志法

**算法思想**：两个进程在**访问完临界区后**会把临界区使用权转交各另一个进程(**每个进程进入临界区权限只能被另一个进程赋予**)

```c
int turn=0;//turn表示当前允许进入临界区的进程号
    
//P0进程:
while(turn!=0);		while(turn!=1);//进入区
critical section;	 critical section;//临界区
turn=1;				 turn=0;		//退出区
remainder section;   remainder section;//剩余区
```

turn表示当前允许进入临界区的进程号，只有允许进入临界区进程在访问了临界区后，才会修改turn的值，对于临界区的访问一定是按P0->P1->P0….

**轮流访问问题**：如果P0一直不访问临界区，虽然临界区空闲，但不许P1访问，违背了**空闲让进**



##### 2. 双标志先检查

**算法思想**：设置一个bool型数组，用数组中各元素**标记各进程想进入临界区的意愿**，每个进程在进入临界区前先检查当前是否有其他进程想进入临界区，如无，则把自身标志设为true，访问临界区

```C
bool flag[2];	//表示进入临界区意愿的数组
flag[0]=false;	
flag[1]=false;	//初始化标志

//P0进程					 P1进程
while(flag[1]);				while(flag[0]);
flag[0]=true;				flag[1]=true;
critical section;			critical section;
flag[0]=false;				flag[1]=false;
remainder section;			remainder section;

//如果处理机在两个进程间切换，可能导致P1和P0同时访问临界区
```

**问题**：违反**忙则等待**原则

**原因**：进入区的检查和上锁是分开执行的，检查后，上锁前可能发生进程切换



##### 3. 双标志后检查

**算法思想**：先检查法的改版，前个算法的问题是检查和上锁无法一气呵成，导致两个进程同时进入临界区，因此先**上锁**后**检查**来避免上述问题

```c
bool flag[2];	//表示愿意进入临界区的进程数组
flag[0]=false;
flag[1]=false;	//设置两个进程都不想进入临界区

//P0进程				P1进程
flag[0]=true;		flag[1]=true;		//进入区
while(flag[1]);		while(flag[0]);
critical section;	critical section;
flag[0]=false;		flag[1]=true;
remainder section;	remainder section;

```

**问题**：违背了**空闲等待**和**有限等待**

**原因**：各进可能程会长期无法访问临界资源产生饥饿（flag[0]=flag[1]=true)



##### 4.  Peterson算法

**算法思想**：如果双方都想进入临界区，那可以让进程主动让对方先使用临界区

```C
bool flag[2];
int turn=0;		//表示优先让哪个进程进入临界区

//P0进程						P1进程
flag[0]=true;					flag[1]=true;			//表示自己想进入临界区
turn=1;							turn=0;					//可以优先让对方进入临界区
while(flag[1] && turn==1]);		while(flag[0] && turn==0);//对方想进入临界区，且最后一次是自己让出机会，则自己循环等待
critical section;				critical section;
flag[0]=false;					flag[1]=false;
remainder section;				remainder section;
```

**问题**：没有遵循**让权等待**的原则，会发生忙等



#### 2.2 硬件实现

##### 1. 中断屏蔽

利用开/关中断指令实现(与原语实现思想相同，某进程开始访问临界区到结束访问为止都不许被中断)

**优点**：简单、高效

**缺点**：不适用于多处理机(开/关中断指令只对当前处理机生效)；只适用于OS内核进程，不适用于用户进程(因为这组指令只能允许在内核态)

##### 2. TestAndset(TS/TSL指令)

TSL指令使用硬件保证检查和上锁操作的方式变为一次呵成的原子操作

```c
//bool型共享变量表示当前临界区是否加锁
//true表示已加锁
bool TestAndset(bool *lock){
    bool old;
    old=*lock;	//存放lock原来的值
    *lock=true;	//无论之前是否加锁，都将lock设为true
    return old;	//返回lock原来的值
}

//以下是使用TSL指令实现互斥算法的算法逻辑
while(TestAndSet(&lock));	//上锁并检查
临界区代码...
lock = false;	//解锁
剩余区代码...
```

**优点**：实现简单，无需像软件实现那样严格检查是否有逻辑漏洞，适合多处理机环境

**缺点**：不满足**让权等待**原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致忙等

##### 3. Swap指令(XCHG指令)

也称Exchange指令

```C
//Swap指令的作用是交换两个变量的值
Swap(bool *a,bool *b){
    bool temp;
    temp = *a;
    *a = *b;
    *b = temp;
}

//Swap指令实现互斥的算法逻辑
//lock表示当前临界区是否被加锁
bool old = true;
while(old = true){
    Swap(&lock,&old);
}
临界区代码段...
lock = false；
剩余区代码段...
```

逻辑上与TSL并无太大区别，都先记录下临界区是否已被上锁(old变量)

**优点**：实现简单，适合多处理机

**缺点**：不满足**让权等待**原则，暂时无法进入临界区的进程会占用CPU并执行TSL指令，导致忙等

----

### 3. 信号量机制

以上所有的解决方案都无法实现**让权等待**，Dijkstra提出一种有效实现进程互斥同步的方法(信号量机制)

用户进程可以使用OS提供的**一对原语**来对信号量进行操作

**信号量**就是一个变量，可以用一个信号量来**表示系统中某种资源的数量**

**原语**是一种特殊的程序段，由关/开中断指令实现。

软件解决方案的主要问题是**进入区的操作无法一气呵成**，因此把进入、退出区的操作用原语来实现

**一对原语**：**wait(S)**和**signal(S)**，可以将原语理解为自己写的函数，名为wait和signal，**信号量S**为函数调用时传入的参数

wait和signal原语常**简称为P、V操作**(来自荷兰语),因此也可写成**P(S)、V(S)**

#### 3.1 整型信号量

用一个**整数型**的信号量，表示OS中某种资源的数量,对信号量的操作只有三种,**初始化、P、V**操作

```C
int S = 1;	//初始化整数型信号量，表示当前OS可用资源数

void wait(int S){	//wait原语，相当于进入区
    while(s<=0);	//资源不够，就循环等待
    S=S-1;			//资源数够，就占用一个资源
}

void signal(int S){		//signal原语，相当于退出区
    S=S+1;				//释放资源
}

//进程P0
...
wait(S);
critical section;
signal(S);
...
```

**优点**：检查和上锁使用原语来保证一气呵成，避免了并发、异步导致的问题

**问题**：不满足**让权等待**原则，会发生忙等(处理机不断while循环)



#### 3.2 记录型信号量

整型信号量的缺陷时存在**忙等**问题，因此用记录型数据结构表示信号量

```C
//	记录型信号量的定义
typedef struct semaphore{
    int value;			//剩余资源数
    struct process *L;	//等待队列
}

//进程通过wait原语申请资源
void wait(semaphore S){
    S.value--;
    if(S.value<0){
        block(S.L);
    }
}

//进程释放资源
void signal(semaphore S){
    s.value++;
    if(S.value<=0){			//说明等待队列中由进程等待
        wakeup(S.L);
    }
}
```

对信号量S的**一次P操作**意味着进程请求一个单位的资源，执行S.value–,表示资源数减一。当S.value<0时表示该类资源分配完，进程调用**block原语**进行自我阻塞(运行态->阻塞态),主动放弃处理机，并插入等待队列中

对信号量S的**一次V操作**意味着释放一个单位的资源，S.value++，若value<=0说明等待队列中由进程，需要调用**wakeuo原语**来唤醒等待队列中的第一个进程(阻塞态->就绪态)

**优点**：遵循了**让权等待**原则，不会出现忙等



#### 3.3 进程互斥实现

1. 分析并发进程的关键活动，划分临界区
2. 设置**互斥信号量** mutex，**初值为1**(可以将临界区看作特殊的系统资源)
3. **对不同临界资源需要设置不同的互斥信号量**
4. 临界区前执行P(mutex)
5. 临界区后执行V(mutex)

```C
//信号量机制实现进程互斥
semaphore mutex=1;	//记录型信号量的简写形式

P1(){
    ...
    P(mutex);
    cricital section;
    V(mutex);
}

P2(){
    ...
    P(mutex);
    cricital section;
    V(mutex);
}
```



#### 3.4 进程同步实现

进程同步：要求各并发进程要求有序地推进，让本来异步并发的进程互相配合，有序推进

1. 分析什么地方需要实现**同步关系**，必须保证**一前一后**执行两个操作
2. 设置**同步信号量S**，**初始化为0**
3. 在**前操作**之后执行V(S)
4. 在**后操作**之前执行P(S)

```C
//信号量机制实现进程互斥
semephore S=0;

p1(){			p2(){
    ...				P(S);
    ...				代码2;
    代码1;			...
    V(S);		}	 	
}				
//保证代码2在代码1后执行

```

先执行V(S)操作后，S++后S=1，之后执行P(S)操作，不会发生block

先执行P(S)操作，S=-1,发生block，后执行V(S)操作,S=0执行wakeup，唤醒P2进程



#### 3.5 前驱关系实现

每一对前驱关系都是一个进程同步问题

1. 为每一对前驱关系设置一个同步变量，初始值为0
2. 在**前操作**之后设置对应同步变量的V操作
3. 在**后操作**之前设置对应同步变量的P操作

画出前驱图，分析

----



### 4. 经典同步问题

#### 4.1 生产者-消费者

生产者、消费者共享一个初始为空、大小为n的缓冲区

只有缓冲区没满，生产者才能把产品放入缓冲区，否则必须等待

只有缓冲区没空，消费者才能从中取走产品。否则必须等待

缓冲区是临界资源，各进程必须互斥访问

![image-20201030110425509](https://gitee.com/happy_every/note_pic/raw/master/image-20201030110425509.png)

**使用信号量机制(P、V操作)实现生产者消费者的功能**

1. 关系分析，分析进程间的同步、互斥关系，发现隐含的同步关系
2. 整理思路，根据各进程的操作流程确定P、V操作的顺序
3. 设置信号量，设置需要的信号量，并确定初值

```C
semaphore mutex = 1;	//互斥信号量
Semaphore empty = n;	//同步信号量，表示空闲缓冲区的数量
semaphore full  = 0;	//同步信号量，表示产品的数量，即非空缓冲区的数量

producer(){
    while(1){
        生产一个产品;
        P(empty);	//消耗一个空闲缓冲区
        P(mutex);
        把产品放入缓冲区;
        V(mutex);
        V（full);	//增加一个产品
    }
}

consumer(){
    while(1){
        P(full);	//消耗一个产品
        P(mutex);
        从缓冲区取走一个产品;
        V(mutex);
        V(empty);	//增加一个空闲缓冲区
        使用产品;
    }
}
```

在生产者消费者中，**实现互斥的P操作一定要在实现同步的P操作后**，否则会发生死锁

V操作不会导致进程阻塞，所以V操作可以交换顺序



#### 4.2 多生产者-多消费者

多类生产者和多类消费者

1. 关系分析，分析各进程间的同步、互斥关系
2. 整理思路，确定各进程的操作流程确定P、V的顺序
3. 设置信号量

![image-20201030112742333](https://gitee.com/happy_every/note_pic/raw/master/image-20201030112742333.png)

```C
semaphore mutex=1;	//互斥访问盘子(缓冲区)	
semaphore apple=0;	//盘子中的苹果数
semaphore orange=0;	//盘子中的橘子数
semaphore plate=1;	//盘子中还可方多少各水果

dad(){
	while(1){
		准备一个苹果；
        
        P(plate);		//盘子是否为空
        P(mutex);
        把苹果放入盘子中
        V(mutex);
        V(apple);		//放入苹果
	}
}

mom(){
	while(1){
        准备一个橘子;
        
        P(plate);
        P(mutex);
        把橘子放入盘子中;
        V(mutex);
        V(orange);
    }
}

daughter(){
    while(1){
        P(apple);		//是否由苹果
        P(mutex);
        从盘中取出苹果;
        V(mutex);
        V(plate);
        
        吃掉苹果;
    }
}

son(){
    while(1){
        P(oranger);
        P(mutex);
        从盘中取出橘子;
        V(mutex);
        V(plate);
        
        吃掉橘子;
    }
}
```

**总结**：在生产者-消费者问题中，如果缓冲区大小为1，那么可以不需设置互斥信号量实现互斥访问缓冲区的功能

从**事件的角度**来考虑，把进程的前后关系抽象为一对事件的前后关系

####  4.3 吸烟者问题

可生产多类产品的单生产者-多消费者问题

![image-20201030131423174](https://gitee.com/happy_every/note_pic/raw/master/image-20201030131423174.png)

1. 关系分析，找出各进程间的同步、互斥关系；桌子上同一时间只能放一种组合
2. 整理思路，确定P、V操作的顺序
3. 设置信号量

![image-20201030131817520](https://gitee.com/happy_every/note_pic/raw/master/image-20201030131817520.png)

```C
semaphore offer1 = 0;	//桌上组合一的数量
semaphore offer2 = 0;	//桌上组合二的数量
semaphore offer3 = 0;	//桌上组合三的数量
semaphore finish = 0;	//抽烟是否完成
int i = 0;				//用于实现吸烟者轮流吸烟

provider(){
    while(1){
        if(i==0){
            将组合一放在桌上;
            V(offer1);
        }else if(i==1){
            将组合二放在桌上;
            V(offer2);
        }else of(i==2){
            将组合三放在桌上;
        	V(offer3);
        }
        
        int i=(i+1)%3;
        P(finish);
    }
}

smoker1(){
    while(1){
        P(offer1);
        拿着组合，抽烟;
        V(finish);
    }
}

smoker2(){
    while(1){
        P(offer2);
        拿着组合，抽烟;
        V(finish);
    }
}

smoker3(){
    while(1){
        P(offer2);
        拿着组合，抽烟;
        V(finish);
    }
}

//不需要设置阻塞信号量，因为同一时刻至多有一个同步信号量为一
```

#### 4.4 读者-写者

有读者和写者两组并发进程，共享一个文件，当多个读进程进程同时访问数据时不会产生副作用，但是写进程和其他进程同时访问数据时，可能导致数据不一致的错误

**要求**：

- 允许多个读者可以同时对文件执行读操作
- 只允许一个写者往文件写信息
- 任意写者完成写操作前不允许其他读者写者工作
- 写者执行写操作前，应让其他读者写者全部退出

**解答**：

1. 关系分析

    - 两类进程：写进程、读进程

    - 互斥关系：写进程——读进程、写进程——读进程

2. 整理思路，确定P、V操作的顺序

3. 设置信号量

    - 读进程与任何进程都互斥，设置互斥信号量rw，在读者和写者访问文件前后执行P、V
    - 但会导致各个读进程间也无法同时访问(**如何处理该问题**)
    - 让第一个访问的读进程加锁，最后一个访问的读进程解锁，设置count记录当前读进程访问文件数

```C
semaphore rw = 1;	//实现对文件的互斥访问,表示当是否有进程在访问文件
int count = 0;		//记录当前有几个读进程在访问文件
semaphore mutex = 1;//用于保证对count变量的互斥访问
semaphore w	= 1;	//实现相对公平的先来先服务原则
write(){
	while(1){
        P(w);
		P(rw);	//写前加锁
		写文件...
		V(rw); 	//写完解锁
        V(W);  
	}
}
read(){
    while(1){
        p(w);
        P(mutex);			//进程互斥访问count
        if(count==0){
            P(rw);		 	//第一个读进程赋负责加锁
        }
        count++;		//访问文件进程数+1
        V(mutex);
        V(w);
        
        读文件...
        P(mutex);
        count--;   
        if(count==0){
            V(rw);
        }
        V(mutex);
    }
}
```

设置另一对信号量来保证各进程对count的访问是互斥的，保证对count的检查和赋值一气呵成(否则可能导致第二个读进程阻塞)

**核心思想**：设置**计数器count**来记录当前访问文件的读进程数，用count可做不同处理，count的检查和赋值不能一气呵成，因想到利用**互斥信号量**

#### 4.5 哲学家进餐

每两个哲学家间放一根筷子，哲学家只有同时拿起左右两个筷子时才可以进餐，否则等待

1. **关系分析**，5位哲学家与左右的哲学家对中间筷子访问是互斥关系
2. **整理思路**，每个哲学家进程需要**同时持有两个临界资源**才能开始吃饭，**如何避免资源分配不当造成的死锁问题**，是哲学家问题的精髓
3. 信号量设置，定义互斥信号量数组chopstick[5]={1,1,1,1,1},用于实现对5个筷子的互斥访问，并对哲学家按0~4编号，哲学家左边的筷子编号位i，右边为(i+1)%5

```c
//方法3
semaphore chopstick[5]={1,1,1,1,1} //五个筷子，五个哲学家
pi(){
    while(1){
        P(mutex);			
        P(chopstick[i]);
        p(chopstick[(i+1)%5]);
        V(mutex);
        吃饭...
        V(chopstick[i]);
        V(chopstick![i+1]%5);
        思考...
    }
}
```

防止死锁的发生

- 可以对哲学家进程施加限制条件，最多允许四个哲学家同时进餐，保证只有有一个哲学家可以拿到两只筷子
- 要求奇数哲学家先拿左边的筷子，再拿右边的筷子，偶数相反（相邻进程抢夺一根筷子）
- 仅当一个哲学家两只筷子都可用才抓起筷子(对拿筷子过程加锁)

---

### 5. 管程

信号量机制存在的问题：编写程序困难、易出错

在Pascal中引入了管程（一种高级同步机制)，分装思想

#### 5.1 管程的定义和基本特征

管程是一种特殊的**共享数据结构**，组成部分：

1. 局部与管程的**共享数据结构**说明
2. 对该数据结构进程操作的**一组过程**(函数)
3. 对局部于管程的共享数据设置初始值的语句
4. 管程有一个名字



基本特征(很像类)：

1. 局部于管程的数据只能被局部于管程的过程访问
2. 一个进程只有**通过调用管程的过程**才能进入进程访问共享数据
3. **每次仅允许一个进程在管程内执行某个内部过程**,这种互斥特性由编译器负责实现
4. 可在管程中设置**条件变量**和**等待、唤醒操作**来解决同步问题，可让一个进程或线程在条件变量上等待(此进程应先释放管程的使用权，让出入口)；等待唤醒

```C
monitor ProducerConsumer
    condition full,empty;	//条件变量来实现同步
	int count=0;			//缓冲区中的产品数

void insert(Item item){	// 把产品放入缓冲区
    if(count===N){
        wait(full);
    }
    count++;
    insert_item(item);
    if(count==1)
        signal(empty);
}

Item remove(){	//从缓冲区中取走产品
    if(count==0){
        wait(empty);
    }
    count--;
    	signal(full);
    return remove_item();
}
end monitor;

//生产者进程
producer(){
    while(1){
        item = 生产一个产品;
        ProducerConsumer.insert(item);
    }
}

//消费者进程
consumer(){
    while(1){
        item = ProducerConsumer.remove();
        消费产品item;
    }
}
```

---



## 2.4 死锁

### 1. 死锁的概念

#### 1.1 什么是死锁

**死锁**：在并发环境下，各进程因竞争资源而造成一种**相互等待对方手中的资源，导致个进程都阻塞，无法向前推进**



#### 1.2 进程死锁、饥饿、死循环的区别

死锁：各进程互相等待对方手中的资源，导致各进程都阻塞

饥饿：由于长期无法得到想要的资源，某进程无法向前推进的现象

死循环：某进程执行过程中一直跳不出某个循环

|        | 区别                                         |
| :----: | :------------------------------------------- |
|  死锁  | 至少由两个及以上进程发生死锁                 |
|  饥饿  | 可能只有一个进程发送饥饿                     |
| 死循环 | 死循环是被管理者的问题，死锁和饥饿是OS的问题 |



#### 1.3 死锁产生的必要条件

产生死锁必须满足四个条件：

**互斥条件**：只有对必须互斥使用资源的争抢才会导致死锁

**不剥夺条件**：在资源未使用完之前，不能由其他进程抢夺，只能主动释放

**请求和保持条件**：进程已经**保持了至少一个资源**，但又提出新的资源请求

**循环等待条件**：存在一种进程资源的循环等待链，链中每个进程获得的资源被下个进程所请求

#### 1.4 死锁发生时机

- 对系统资源的竞争，各进程对**不可剥夺资源**的竞争可能引起死锁，对可剥夺资源(cpu)的竞争不会引起死锁
- 进程推进顺序非法，请求和释放资源的顺序不当
- 信号量使用不当，如生产者-消费者问题中，实现互斥的P放在实现同步P前，就可能导致死锁(可以将互斥、同步信号量看作是一种抽象的系统资源)



### 2. 死锁的处理策略

**预防死锁**：破坏死锁的产生四个必要条件的一个或多个

**避免死锁**：用某种方法防止系统进入不安全状态(银行家算法)

**死锁的检测和避免**：允许死锁发生，不过OS会负责检测检测出死锁的发生，然后采取某种措施消除死锁

#### 2.1 死锁的预防

##### 1.破坏互斥条件

**互斥条件**：必须互斥使用的资源的抢夺才会导致死锁

把只能互斥使用的资源改造成允许共享使用，如**SPOOLing**技术

![image-20201030164605178](https://gitee.com/happy_every/note_pic/raw/master/image-20201030164605178.png)

**缺点**：并不是所有资源都可改造成可共享使用的资源，并且为了系统安全，很多地方还必须保护这种互斥性，**很多时候都无法波坏互斥条件**

##### 2.  破坏不剥夺条件

**不剥夺条件**：进程所获得的资源在未使用完前，不能由其他进程强行夺走，只能主动释放

破坏不剥夺条件的两种方式：

1. 当进程请求新的资源得不到满足时，必须释放保存的所有资源，主动释放资源
2. 当进程需要资源被占用时，由OS协助，抢夺资源；需要考虑各进程的优先级

**缺点**：

1. 实现复杂
2. 释放已获得的资源可能造成前已阶段工作失效，这种方法只适用于易保存和恢复的资源，如CPU
3. 反复地申请和释放资源会增加系统开销，降低系统吞吐量
4. 若采用方案一，可能会导致进程饥饿



##### 3. 破坏请求和保持条件

请求和保持条件：进程**已经保持了至少一个资源**，但有申请了新的资源，该资源被其他资源占有，此时进程被阻塞且保持自身资源

**静态分配方法**：在进程运行前一次申请完所需的资源，在资源未满足前，不投入允许

**缺点**：有些进程可能只要使用很短时间的资源，运行期间一直保持所有资源会造成资源浪费，**资源利用率低**，也会导致进程饥饿



##### 4. 破坏循坏等待条件

循坏等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被下一进程所请求

**顺序资源分配法**：首先给系统中的资源编号，规定每个进程必须按**编号递增的顺序请求资源**，同类资源(编号相同)一次申请完

因为一个进程已占有小编号资源时，才有资格申请更大编号的资源，已持有大编号的进程不可能逆向申请小编号资源，不会产生循环等待的现象

**缺点**：

1. 不方便增加新的设备，可能需要重新编号
2. 进程实际使用顺序和编号递增顺序不一致，会导致资源浪费
3. 必须按规定次序申请资源，用户变成麻烦



#### 2.2 死锁的避免

##### 1.安全序列

安全序列：如果系统安装这种序列分配资源，每个进程都能顺利完成，只要能找出一个安全序列，系统就是**安全状态**，安全序列可能有多个

##### 2. 不安全状态

如果分配资源后，系统找不出一个安全序列，系统就进入了**不安全状态**,意味之后可能所有进程都无法顺利的执行下去

如果有进程提前归还了一些资源，那**系统可有可能重新回到安全状态**

如果系统处于**安全状态**，就一定不会发生死锁，如果进入不安全状态，就**可能发生死锁**

因此可以在**资源分配前预先判断这次分配是否会导致系统进入不安全状态**，来决定是否答应资源分配请求，这就是**银行家算法**的核心思想



##### 3. 银行家算法

由Dijkstra为银行系统设计，确保银行能满足所有客户的贷款需求，后被用在OS中，用于**避免死锁**

**数据结构**:

- 长度为m的一维数组Available表示还有多少可用资源
- n*m矩阵Max表示各进程对资源的最大需求数
- n*m矩阵Allocation表示已经给各进程分配了多少资源
- Max-Allocation=Need 矩阵表示各进程最多还需多少资源
- 用长度为m的一维数组Request表示进程此次申请的各种资源数

**算法步骤**:

1. 检查此次申请是否超过了之前申明的最大需求数
2. 检查此时系统剩余的可用资源是否还能满足这次请求
3. 试探着分配，更改各数据结构
4. 用安全性算法检查此次分配是否会导致系统进入不安全状态

**安全性算法步骤**：

1. 检查当前的剩余可用资源是否能满足某个进程的最大需求，如果可以，就把该进程加入安全序列，并把该进程持有的资源全部回收
2. 不断重复上诉过程，看最终是否能让所有进程都加入安全序列

#### 2.3 死锁的检测和解除

##### 1. 死锁的检测

为了能对系统是否已发生了死锁进行检测，必须：

1. 用**某种数据结构**来保存资源的请求和分配信息
2. 提供**一种算法**，用上述信息来检测系统是否发生了死锁

**数据结构**：

- 两种节点

    - 进程节点：对应一个进程
    - 资源节点：对应一类资源，一类资源可能会有多个

- 两种边

    - 进程节点->资源节点：表示进程想申请几个资源(每条边代表一个)
    - 资源节点->进程节点：表示已经为进程分配了几个资源(每条边表示一个)

    ![image-20201030191004450](https://gitee.com/happy_every/note_pic/raw/master/image-20201030191004450.png)

如果系统中剩余资源足够满足进程需求，就消除边。

如果最终不能消除所有边，那么最终还连着边的那些进程就是处于死锁状态的进程

**检测死锁算法**(依次消除与不阻塞进程相连的边，直到无边可消)：

1. 在资源分配图中，找出既不阻塞也不是孤点的进程Pi(即找出一条有向边与之相连，且对应资源申请数小于等于系统中已有空闲资源数)，然后释放该节点占用的资源，消除它的所有请求边和分配边，使之成为孤立的节点
2. 唤醒某些因等待资源而阻塞的进程，不断简化分配图，如果消去所有边，则称该图是**可完全简化**

**死锁定理**：如果某时刻资源分配图是**不可完全简化**，那么此时系统死锁



##### 2. 死锁的解除

一旦检测出死锁的发生，就立即解除死锁

用死锁检测算法化简资源分配图后，还连着边的那些进程就是死锁进程

**解除死锁的主要方法**：

- **资源剥夺法**：挂起某些死锁进程，并抢占它的资源，但是要防止被挂起进程饥饿
- **撤销进程法**(终止进程法)：强制撤销部分、全部死锁进程，并剥夺资源。实现简单，但是代价很大，因为某些进程可能已经运行了很长时间
- **进程回退法**：让一个或多个进程回退到足以避免死锁的地步，要求OS记录进程的历史信息，设置还原点

如何决定对哪个进程处理：

- 进程优先级
- 已执行时间
- 还需执行时间
- 进程已经使用多少资源
- 进程是交互式还是批处理



